Question;Answer;AnswerPl;Type;Qualification;IsActive
What is meant by RGB stream?;RGB represents colors in CSS. The three streams are namely Red, Green, and Blue. The intensity of colors is represented using numbers 0 to 256. This allows CSS to have a spectrum of visible colors.;RGB reprezentuje kolory w CSS. Trzy strumienie to czerwony, zielony i niebieski. Intensywność kolorów jest reprezentowana za pomocą liczb od 0 do 256. Dzięki temu CSS może mieć spektrum widocznych kolorów.;CSS;;false
What are Lists in HTML? (HTML Lists);HTML lists are used to group a set of related items in lists. It is defined with an <li> tag. Some commonly used HTML lists: 1. Ordered List (HTML tag: <ol>) 2. Unordered List (HTML tag: <ul>) 3. Description List (HTML tag: <dl>) 4. Menu List (HTML tag: <menu>) 5. Directory List (HTML tag: <dir>);Listy HTML służą do grupowania zbioru powiązanych elementów na listach. Są zdefiniowane za pomocą znacznika <li>. Niektóre powszechnie używane listy HTML: 1. Lista uporządkowana (tag HTML: <ol>) 2. Lista nieuporządkowana (tag HTML: <ul>) 3. Lista opisowa (tag HTML: <dl>) 4. Lista menu (tag HTML: <menu>) 5. Lista katalogów (znacznik HTML: <dir>);HTML;;true
Are CSS styles inherited? (CSS inheritance);Some styles are inherited down the HTML tree and some are not. Typically, styles that are inherited are text styling. Styles that are not inherited are typically related to the appearance of the element.;Niektóre style są dziedziczone w dół drzewa HTML, a niektóre nie. Style, które są dziedziczone są zazwyczaj połączone ze stylowaniem tekstu. Style, które nie są dziedziczone są zazwyczaj związane z wyglądem elementu.;OOP;;true
What is a semantic HTML?;The semantic HTML elements clearly describe their use by their name. For example, non-semantic elements are <div> and <span> (they say nothing about the content), and semantic elements are <form>, <table>, and <article> (they clearly describe what is in them).;Semantyczne elementy HTML jasno opisują swoje zastosowanie poprzez swoją nazwę. Dla przykładu niesemantyczne elementy to <div> i <span> (nic nie mówią o zawartości), a semantyczne to <form>, <table>, i <article> (jasno opisują co ma się w nich znaleźć).;CSS;;true
Describe Angular's bootstrapping process.;The main.ts file is loaded by angular.json, then it loads app.module and this makes Angular aware of the AppComponent. Then index.html is loaded in the browser which loads the AppComponent that uses the view specified in that component.;Plik main.ts jest ładowany przez angular.json, wtedy ładuje on app.module i to powoduje, że Angular jest świadom AppComponentu. Następnie index.html jest załadowany w przeglądarce, który ładuje AppComponent używające widoku określonego w tym komponencie.;Angular;;false
How does absolute positioning work? (position absolute, position: absolute);Element with 'position: absolute' is removed from the normal HTML document workflow without creating any space for the element in the HTML page layout. The element can be positioned respectively to the closest ancestor ancestor with different position than static, otherwise, if the ancestor is not found, the element is placed with respect to <html> tag. The values provided to the top, right, left and bottom determine the final position of the element.;Element z 'position: absolute' jest usuwany z normalnego workflow na dokumencje HTML - nie tworzy się na nim miejsca na element w układzie strony HTML. Element może być umieszczony relatywnie do najbliższego przodka z pozycją inną niż static, w przeciwnym razie, jeśli przodek nie zostanie znaleziony, element zostanie umieszczony w odniesieniu do znacznika <html>. Wartości podane w top, right, left, i bottom określa ostateczną pozycję elementu.;CSS;;true
Can an abstract class contain normal methods?;Yes, if we want to override a method in a derived class, we need to add 'override' before method name.;Tak, jeżeli chcemy umożliwić nadpisywanie metody w klasie pochodnej musimy dodać override przed nazwą metody.;OOP;;false
How does 'this' work? (this., JavaScript this);If the function is in an object, this will be that object. The exception is the arrow function, which does not create a new context, its this context is one level up. The "this" keyword refers to the object that the function is a property of. The value of the "this" keyword will always depend on the object that is invoking the function.;Jeżeli funkcja jest w obiekcie - this to będzie ten obiekt. Wyjątkiem jest funkcja strzałkowa, która nie tworzy nowego kontekstu, jej kontekst this jest poziom wyżej. The “this” keyword refers to the object that the function is a property of. The value of the “this” keyword will always depend on the object that is invoking the function.;JavaScript;;true
What is tsconfig.json?;In the file, we can specify various options with information on how to compile the project. The presence of this file in a folder determines that it is the root of a TypeScript project.;W pliku możemy określić różne opcje z informacjami jak skompilować projekt. Obecność tego pliku w folderze określa, że jest on root'em projektu TypeScriptowego.;TypeScript;;true
What Injectors are over the root ModuleInjector?;1. ModuleInjector defined by plaformBrowser when bootstrapping the main application module (AppModule where the root ModuleInjector is located): platformBrowserDynamic(). BootstrapModule (AppModule) .then (ref => {...}) 2. NullInjector(), which is at the very top of the hierarchy and if we hit it we get an error or null if we specified the parameter as @Optional().;1. ModuleInjector definiowany przez plaformBrowser podczas bootstrapowania głównego modułu aplikacji (AppModule, w którym znajduje się root ModuleInjector): platformBrowserDynamic().bootstrapModule(AppModule).then(ref => {...}) 2. NullInjector(), który jest na samej górze hierarcji i jeżeli doszliśmy do niego dostajemy error albo null jeżeli określiliśmy parametr jako @Optional().;Angular;;false
Why does the app need state management?;Let's assume a situation where the username is written in the header of the page. There is a page for editing the username in the application. What will happen when we change the username? If header only gets the username from the database on initialization then the username will stay the same until we reload the page, which is not the correct solution. We can also create a website that gets updated data from the editing page and sends it to the header, but very quickly it ends up with a lot of hard-to-maintain code. The most practical will be to use a single data source, which means keeping the data about the user in the application state after authentication and sending the data from the state to both the head and the edit page, updating the state after editing. In Angular, NgRx is used for this, a great advantage of which is also the ability to display the current state of the application in the browser.;Załóżmy sytuację, w której w headerze na stronie mamy napisaną nazwę użytkownika. W aplikacji znajduje się strona do edycji nazwy użytkownika. Co się stasnie jak zmienimy nazwę użytkownika? Jeżeli header pozyskuje nazwę użytkownika z bazy danych tylko przy inicjalizacji, wtedy nazwa użytkownika zostnaie taka sama do czasu, aż nie przeładujemy strony, co nie jest poprawnym rozwiązaniem. Możemy też stworzyć serwis, który dostaje zaktualizowane dane ze strony edycji i wysyła je do headera, jednak bardzo szybko kończy się to dużą ilością ciężkiego w utrzymaniu kodu. Najbardziej praktyczne będzie użycie pojedyńczego źródła danych, co oznacza trzymanie danych o użytkoniku w stanie aplikacji po autentykacji i wysłanie danych ze stanu zarówno do headera jak i strony edycji, po edycji aktualizując stan. W Angularze stosuje się do teog NgRx, którego bardzo dużym plusem jest też możliwość wyświetlenia aktualnego stanu aplikacji w przeglądarce.;Angular;;false
Explain stack vs heap.;The stack holds function calls, local variables, and simple values. As the program runs functions, they are stacked in a LIFO queue. Each thread has its own stack. The stack has a predetermined size. The heap does not have a predetermined size, the size is dynamically allocated. Used to hold the values ​​of reference types because they are too large to hold on the stack.;Stos przetrzymuje wywołania funkcji, zmienne lokalne oraz wartości proste. Jak program uruchamia funkcje są one nakładane na stos w kolejkę LIFO. Każdy wątek ma swój stos. Stos ma określony z góry rozmiar. Sterta nie posiada określonego z góry rozmiaru, rozmiar jest dynamicznie alokowany. Służy do przetrzymywania wartości typów referencyjnych, ponieważ są one zbyt duże, żeby trzymać je na stosie.;OOP;;false
What is Subject?;Subject is a special type of observabli which is both an observable and observator, ie we can both specify it as a function of a subscription (observator) and subscribe to it.;Subject jest specjalnym typem observabli, która jest zarówno observable jak i observatorem, tzn. możemy zarówno podać go jako funkcja subskrypcji (observator), jak i zasubkrybować do niego.;Angular;;true
What is PWA? (Progressive Web Application);PWA is a type of the web application that uses service worker for cache management of the application. It's great way to improve performance because application is being loaded almost instantly from the memory and in the background service worker checks if newer version needs to be downloaded. PWA functionality also enables us to install the application on our device just like a desktop or mobile application and lets view the application if we are online by loading it from cache.;PWA to typ aplikacji webowej, która wykorzystuje Service Worker do zarządzania cach'em aplikacji. To świetny sposób na poprawę wydajności, ponieważ aplikacja jest ładowana niemal natychmiast z pamięci, a w tle Service Worker sprawdza, czy nie trzeba pobrać nowszej wersji. Funkcjonalność PWA umożliwia nam również zainstalowanie aplikacji na naszym urządzeniu tak jak aplikacji desktopowej lub mobilnej oraz umożliwia przeglądanie aplikacji, jeśli jesteśmy online, ładując ją z pamięci podręcznej.;Angular;;true
What are Pure Components? (pure component, czysty component, czyste componenty);"Pure" component means that its entire state is represented by its Inputs(), which are immutable.;"Pure" komponent oznacza, że jego cały stan jest reprezentowany przez jego Inputy(), które są niezmienne (immutable).;Angular;;false
What is Set object?;Set is a special type of collection - a "set of values" in which each value can occur only once. An alternative to Set could be an array of code that checks for duplicates, but performance would be much worse. Set is much better optimized for uniqueness checking.;Set jest specjalnym typem kolekcji - "zestawem wartości", w którym każda wartość może wystąpić tylko raz. Alternatywą dla Set mogłaby być tablica z kodem, który sprawdza czy nie ma w niej duplikatów, jednak wydajność byłaby dużo gorsza. Set jest dużo lepiej zoptymalizowany do sprawdzania unikatowości.;Angular;;true
What are the main requirements for good HTML and CSS?;1. Responsive design 2. Maintainable and scalabe code 3. Web performance;1. Responsive design 2. Utrzymywalny i skalowalny kod 3. Wydajność;CSS;;false
What are cookies?;Cookies are small information files that the web server generates and sends to your browser. The browser keeps cookies, which it receives for a defined period of time. They have an expiry time, if not defined the cookie will expire with the browser session. Up to 4KB. Sent to the server with every request.;Cookies są małymi plikami z informacjami, które web serwer generuje i wysyła do przeglądarki. Przeglądarka przetrzymuje cookies, które dostaje na zdefiniowany okres czasu. Mają czas wygaśniecią, jeżeli nie został on zdefiniowany cookie wygaśnie z sesją przeglądarki. Do 4KB. Wysyłąne do servera z każdym zapytaniem.;Angular;;true
Why don't we use modifiers like async, public, private etc. in the interfaces? (interfejs);The interface is a contract that tells us how the method should behave, and modifiers like async, public, private tell us how the method is implemented, which makes it implementation information and implementation information not part of the contract.;Interfejs jest kontraktem, który mówi nam w jaki sposób metoda powinna się zachowywać, a modyfikatory typu async, public, private mówią nam jak metoda jest zaimplementowania, co powoduje, że jest to informacja na temat implementacji, a informacje na temat implementacji nie są częścią kontraktu.;OOP;;true
How is form.setValue () different from form.patchValue ()?;Both methods set the value of the form except that setValue cannot omit any field.;Obie metody ustawiają wartość formularza z tą różnicą, że setValue nie może pominąć żadnego pola.;Angular;;false
What is hoisting?;Hoisting works by taking the declaration (not initialization) of variables and functions (declared as var) "to the top" of the code (specifically to the beginning of the function or to the range of global variables, depending on where the variable or function was declared). This means that you can refer to a variable or function before it's even declared.;Hoisting polega na wynoszeniu deklaracji (nie inicjalizacji) zmiennych i funkcji (zadeklarowanych jako var) „na górę” kodu (konkretnie na początek funkcji lub do zakresu zmiennych globalnych, w zależności od tego, gdzie dana zmienna lub funkcja została zadeklarowana). Oznacza to, że można odwołać się do zmiennej lub funkcji zanim jeszcze zostanie zadeklarowana.;JavaScript;;true
What is the difference between Annotation and Decorator in Angular?;The Decorator corresponds to the function that is called on the class, Annotations are "only" metadata on the class. Angular uses Decorators.;Decorator odpowiada funkcji, która jest wołana na klasie, Annotations są "tylko" metadanymi na klasie. Angular używa Decoratorów.;Angular;;false
What is polyfills.ts for?;Polyfills in Angular are a few lines of code that make the application cross-browser compatible. Polyfills.ts is created by Angular with default settings so it doesn't implement everything yourself.;Polyfills w Angularze to pare linii kodu, które powodują, że aplikacja jest kompatybilna dla różnych przeglądarek. Polyfills.ts jest tworzony przez Angulara z domyślnymi ustawieniami, żeby nie implementować wszystkiego samemu.;Angular;;true
Why do modules have to import eg CommonModule separately?;Each new module is in a clean state. There is no knowledge of anything. We need to import everything we need for whatever component declared in it. Modules do not inherit access to components, directives, or pipes that are declared in other modules. That's why we need to import eg CommonModule to have access to ngIf, ngFor, etc. in our components. Our new module knows nothing about directives from other modules. It only looks for imported modules in declarations and exports.;Każdy nowy moduł ma czysty stan. Nie ma wiedzy odnośnie niczego. Musimy zaimportować wszystko czego potrzebujemy dla jakiegokolwiek componentu zadeklarowanego w nim. Moduły nie dziedziczą dostępu do componentów, dyrektyw, lub pipe'ów, którę są zadeklarowane w innych modułach. Dlatego musimy zaimportować np. CommonModule, żeby w naszych componentach mieć dostęp do ngIf, ngFor, itd. Nasz nowy moduł nic nie wie o dyrektywach z innych modułów. Szuka tylko w deklaracjach i exportach zaimportowanych modułów.;Angular;;true
What is VAPID key pair?;VAPID stands for Voluntary Application Server Identification for Web Push. The VAPID key pair is a cryptographic public/private key pair that is used as follows: -The public key is used as a server unique identifier when subscribing a user to notifications sent by that server. -the private key must be a secret (as opposed to the public key) and is used by the application server to sign the message before sending.;VAPID oznacza Voluntary Application Server Identification dla protokołu Web Push. VAPID key pair jest kryptograficznym publiczną/prywatną parą kluczy, która jest używana w następujący sposób: - klucz publiczny jest używany jako unikatowy identyfikator serwera podczas subskrybowania użytkownika  do notyfikacji wysyłanych przez ten serwer. - klucz prywatny musi być sekretem (w odróżnieniu od klucza publicznego) i jest używany przez serwer aplikacji do podpisu wiadomości przed wysyłką.;Angular;;false
What is the ng-container directive and in what cases can it be useful?;We use ng-container if we want to conditionally show the html fragment, but we don't want this fragment to be 'wrapped' in any element. Angular does not render the ng-content element. I used ng-content in conjunction with the css grid, for example, to create a grid for each * ngFor interaction.;ng-container używamy jeżeli chcemy warunkowo pokazać fragment html, ale nie chcemy, żeby ten fragment był 'opakowany' w żaden element. Angular nie renderuje elementu ng-content. Ja używałem ng-content np. w połączeniu z css grid, żeby stworzyć grida dla każdej interacji *ngFor.;Angular;;true
What is the difference between value and ngValue?;You can use both value and ngValue. The only difference is that value must always be a string, while in ngValue we can pass an object.;Można używać zarówno value jak i ngValue. Jedyna różnica jest taka, że value musi zawsze być stringiem, natomiast w ngValue możemy przekazać obiekt.;Angular;;false
to override;to override;to override;CSS;;false
What is the difference between DebugElement and nativeElement?;nativeElement returns a reference to the DOM of an element. DebugElement is an Angular class that contains nativeElement along with other essential methods and references for unit tests.;nativeElement zwraca referencje do DOM elementu. DebugElement jest klasą Angulara, która zawiera w sobie nativeElement wraz z innymi istotnymi metodami i referencjami przydatnymi w unit testach.;Testing;;true
Most important HTML APIs. (WebAPI, HTMLAPI);1. Geolocation API, used to identify the user’s location. 2. Web Speech API, which provides speech recognition functionality. 3. Clipboard API, which provides copy, cut, and paste functionality. 4. History API, which provides access to the browser navigation history. 5. Web Notifications API, used to send web-based notifications to users.;1. Geolokalizacji API, służące do identyfikacji lokalizacji użytkownika. 2. Web Speech API, który zapewnia funkcjonalność rozpoznawania mowy. 3. Clipboard API, który zapewnia funkcje kopiowania, wycinania i wklejania. 4. History API, które zapewnia dostęp do historii nawigacji w przeglądarce. 5. Web Notifications API, służący do wysyłania użytkownikom powiadomień internetowych.;HTML;;true
How can the performance of an HTML web page be measured? (search: performange tools, tools for performance);[understand, write better] I heard that popular solutions include the Navigation Timing API and the User Timing API that provide performance metrics suck as: 1. Page load speed: The time it takes for the full page to load. 2. Time to interact: The time it takes for the user to be able to interact with the page. 3. Bounce rate: The proportion of users that leave the page without interacting with it. 4. Error rate: The proportion of visits to the page resulting in errors.;[zrozumieć, napisać lepiej] Słyszałem, że popularne rozwiązania to między innymi Navigation Timing API i User Timing API, które dostarczają metryki wydajności, które są do bani: 1. Szybkość ładowania strony: czas potrzebny na załadowanie całej strony. 2. Czas na interakcję: czas potrzebny użytkownikowi na interakcję ze stroną. 3. Współczynnik odrzuceń: odsetek użytkowników, którzy opuszczają stronę bez interakcji z nią. 4. Wskaźnik błędów: Odsetek wizyt na stronie skutkujących błędami.;HTML;;true
What is exhaustMap and how does it work?;exhaustMap is a higher-order mapping operator. It is used to support nested Observables. If the nested Observable is being invoked and a new source Observable arrives, it is ignored. The new Observable sources are considered as all earlier Observables have finished their operation. An example may be login requests, if the first request has not yet received a response, we ignore all requests in the meantime.;exhaustMap jest operatorem typu Higher-order mapping. Służy do obsługi zagnieżdżonych Observabli. Jeżeli zagnieżdzony Observable jest w trakcie wywoływania, a przyjdzie nowy źródłowy Observable to jest on ignorowany. Nowe źródłowe Observable są brane pod uwagę jak wszystkie wcześniejsze Observable skończyły swoje działanie. Przykładem może być requesty o login, jeżeli pierwszy request nie przyniósł jeszcze odpowiedzi to ignorujemy wszystkie requesty w międzyczasie.;Angular;;false
What is Spy?;Spy is an object that controls which it's method has been run, how many times it has been run, and what parameters have been used in it.;Spy jest obiektem, który kontroluje jaka jego metoda została uruchomiona, ile razy została uruchomione i jakie parametry zostały w niej użyte.;Testing;;true
What methods do you know for combining Observables?;1. combineLatest([obs1, obs2, ...]) - will emit the combined value of the given Observables if they all emitted something and each time emits a value. 2. forkJoin([obs1, obs2, ...]) - will emit only when all observable have finalized their data transfer. 3. withLatestFrom - emitule if all observable emits, then every time the source Observable emits.;1. combineLatest([obs1, obs2, ...]) - wyemituje połączoną wartość podanych Observabli, jeżeli wszystkich one już coś wyemitowały i za każdym razem jakaś wyemituje wartość. 2. forkJoin([obs1, obs2, ...]) - wyemituje tylko kiedy wszystkie observable sfinalizują przesyłanie danych. 3. withLatestFrom - wyemitule jeżeli wszystki observable wyemitują, a później za każdym razem jak źródłowa Observable wyemituje.;Angular;;false
What are Closures?;A closure is a combination of a function combined with a reference to its surrounding state. In other words, a closure gives access to the outer scopa of the function inside that function. In JavaScript, closures are created each time a function is created.;Domknięcie jest kombinacją funkcji połączonej z referencją do jej otaczającego stanu. Innymi słowy, domkniecie daje dostęp do zewnętrznego scopa funkjcji wewnątrz tej funkcji. W JavaScripcie domknięcia są tworzone za każdym razem jak funkcja jest stworzona.;Angular;;true
What does propery runGuardsAndResolvers: 'paramsOrQueryParamsChange' do when used inside route's definition?;It makes Guards and Resolvers run again when we navigate to the same URL but with different query parameters.;Powoduje, że Guardy i Resolvery uruchamiają się ponownie podczas nawigacji do tego samego URL ale z innymi query parameterami.;Angular;;false
What does it mean that CSS is cascading?;Cascade is the process of combining different stylesheets and resolving conflicts between different CSS declarations and rules, when more than one rule is applied to one element.;Kaskada to jest process łączenia różnych stylesheet'ów i rozwiązywanie konfliktów pomiędzy różnymi CSS deklaracjami i zasadami, kiedy więcej niż jedna zasada aplikuje się na jeden element.;CSS;;false
What are Modules in Angular?;Angular modules are cohesive blocks of functionality that help organize the application.;Moduły w Angularze są to spójne bloki funkcjonalności, które pomagają w organizacji aplikacji.;Angular;;true
What happens when we set box-sizing: border-box for an HTML element?;The defined value in width and height properties will apply to content, padding, and border, not only to the content as it is in case of using box-sizing: content-box.;Określona wartość propercij width i height będzie tyczyła się contentu, paddingu, i borderu, nie tylko contentu jak w przypadku box-sizing: content-box.;CSS;;false
What is Material Design (refer to Angular Material);Material Design is not an Angular specific design instead Material Design is a design specification from Google that defines how user interface should look. In Android phone many of user interfaces that you interact with follow the design speficication. Angular Material is a UI library for Angular based on Material Design.;Material Design nie jest wyłącznie Angularowym designem, ale jest specyfikacją designową od Google, która określa jak interfejs użytkownika powinien wyglądać. W Androidzie wiele interfejsów użytkownika kierują się tym designem. Angular Material jest biblioteką UI do Angulara bazującą na Material Design.;Angular;;false
What is ARIA?;Accessible Rich Internet Applications (ARIA) is a set of roles and attributes that make the application more accessible to people with disabilities. The point is for readers to clearly read the content of the page. The first rule of ARIA is not to use ARIA when not needed, but to use native HTML elements or attributes with semantics and behavior already built into HTML.;Accessible Rich Internet Applications (ARIA) jest zestawem roli i atrybutów (roles and attributes), dzięki którym aplikacja staje się bardziej dostępna dla ludzi z niepełnosprawnościami (disabilities). Chodzi o to, żeby readery jasno czytały content strony. Pierwszą zasadią ARIA jest żeby nie używać ARIA kiedy nie ma takiej potrzeby, tylko używać natywnych elementów HTML albo atrybutów z semantyką i zachowaniem, które już jest wbudowane w HTML.;HTML;;true
What is Event Loop?;It's a mechanism that has one simple job - it looks at the Call Stack and at the Callback Queue, and if the Call Stack is empty it gets the first position (the first callback function) from the Callback Queue to the Call Stack.;To mechanizm, który ma jedną prostą pracę - patrzy na Call Stack i na Callback Queue, i jeżeli Call Stack jest pusty pobiera pierwszą pozycję (pierwszą callback function) z Callback Queue na Call Stack.;JavaScript;;true
How does the done() function work in Angular tests?;The done() function is passed as a parameter to the test, then the test waits for this function to be called and exits as it was called. If the test does not call the done() function within the specified time (5sec by default), an exception will be thrown.;Funkcja done() jest przekazywana jako parametr do testu, po czym test jest oczekuje na wywołanie tej funkcji i skończy działanie jak zostanie wywołana. Jeżeli test nie wywoła funkcji done() w określonym czasie (domyślny to 5sek) zostanie wyrzucony wyjątek.;Testing;;true
How do we use the ActivatedRoute?;ActivatedRoute has: -url segments, -route parameters, -query parameters, -resolver data. There are two ways to get data from ActivatedRoute. The first is to refer to a snapshot, which provides the initial state of the path when entering the component. The second is to subscribe to paramMap: route.paramMap.subscribe() in order to observe the current path values.;ActivatedRoute posiada: -segmenty URL, -parametry route'a, -query parametry, -resolver data. Są twa sposoby na pozyskanie danych z ActivatedRoute. Pierwszy z nich to odwołanie się do snapshota, który zapewnia początkowy stan ścieżki kiedy wchodzimy w dany komponent. Drugi to zasubskrybowanie do paramMap: route.paramMap.subscribe(), w celu obserwowania aktualnych wartości ścieżki.;Angular;;false
What is Web Accessibility?;A way to develop websites for people with disabilities to use them. The WCAG standard is Web Accessibility guidelines that consist of four principles: 1. Perceivable - users with limitations should have it easier to find themselves in the application using their senses (e.g. adding alternative text to images for the blind, appropriate color contrast, appropriate font size, semantic html mainly for screen readers because they know how navigate semantic html elements). 2. Operable - making it easier to navigate the application and use the functionalities (e.g. people with mobility limitations should be able to use the keyboard instead of the mouse). 3. Understandable - information on the website and its operation should be clear and understandable. The website should behave in an intuitive/predictable way (e.g. consistent appearance and operation of elements on all pages of the application, clear messages).4. Robust - the application should work on as many devices and browsers as possible.;Sposób rozwijania stron internetowych, żeby ludzie z niepełnosprawnością mogli ich używać. Standard WCAG to wytyczne Web Accessibility składające się z czterech zasad: 1. Postrzegalność (Perceivable) - użytkownicy z ograniczeniami powinni mieć ułatwione odnalezienie się w aplikacji za pomocą swoich zmysłów (np. dodanie tekstu alternatywnego do obrazków dla osób niewidomych, odpowiedni kontrast kolorów, odpowiedni rozmiar czcionek, semantyczny html głównie dla screen readerów ponieważ wiedzą jak poruszać się po semantycznych elementach html). 2. Funcjonalność (Operable) - ułatwianie w poruszaniu się po apliklacji i używaniu funcjonalności (np. osoby z ograniczeniami ruchowymi powinny być w stanie korzystać z klawiatury zamiast z myszki). 3. Zrozumiałość (Understandable) - informacje na stronie i jej obsługa powinny być jasna i zrozumiała. Strona powinna zachowywać się w sposób intuicyjny/przewidywalny (np. spójny wygląd i działanie elementów na wszystkich stronach aplikacji, przejrzyste komunikaty).4. Solidność (Robust) - aplikacja powinna działać na jak największej ilości urządzeń i przeglądarkach.;HTML;;true
What is an Anchor tag in HTML? (<a>);An anchor tag is used to link two sections, web pages, or website templates in HTML.;Anchor tag służy do łączenia dwóch sekcji, stron internetowych lub szablonów witryn internetowych w kodzie HTML.;HTML;;false
Describe Responsive Design (RWD);It is a design approach that aims to build web pages that detect the orientation and screen size of the users so the layout can change accordingly. This approach uses flexible layouts, flexible images, and CSS Media Queries. We apply it by using dynamic grids and layouts that in easy way adaps to screen, we use % instead of units like pixels (px) for lenght. We use Media Queries to change the page styles for different screen sizes.;To podejście, w którym budujemy aplikację wykrywającą rozmiar ekranu użytkownika, żeby layout mógł się do niego dostosować. To podejście wykorzystuje elastyczne layouty, image i CSS Media Query. Projektujemy go za pomocą dynamicznych gridów i layoutów, które w łatwy sposób dopasowują się do ekranu, używamy % zamiast jednostek takich jak piksele (px) dla długości. Używamy Media Query aby zmieniać style strony dla różnych rozmiarów ekranu.;CSS;;true
Enumerate JavaScript primitive types. (typy prymitywne);string. number. bigint. boolean. undefined. symbol. null.;string. number. bigint. boolean. undefined. symbol. null.;TypeScript;;true
What is Polymorphism? Explain and give an example. (Polimorfizm);Polymorphism is when classes have different functionality but share the same interface. An example would be a disc player that plays both BluRay and DVD discs. This concept is also common in programming.;Polimorfizm jest wtedy kiedy klasy mają różną funkcjonalność, ale dzielą ten sam interfejs. Przykładem może być odtwarzacz płyt, który odtwarza zarówno płyty BluRay, jak i DVD. Ta koncepcja jest również powszechna w programowaniu.;OOP;;true
What was the purpose of developing CSS?;CSS was developed to define the visual appearances of websites. It allows developers to separate the structure and content of a website that was not possible before.;CSS został opracowany w celu zdefiniowania wizualnego wyglądu stron internetowych. Pozwala programistom na rozdzielenie struktury i zawartości strony internetowej, co wcześniej nie było możliwe.;CSS;;true
What are mixins?;A mixin is a way to reuse couple of lines of CSS. It outputs that lines directly where a specific mixin is used.;Mixin to sposób na ponowne wykorzystanie kilku linijek CSS. Mixin wyprowadza te linie bezpośrednio tam, gdzie używany.;CSS;;true
What is the difference between null and undefined?;Undefined means a variable has been declared but has not yet been assigned a value. null is an assignment value. It can be assigned to a variable as a representation of no value.;undefined oznacza, że ​​zmienna została zadeklarowana, ale nie przypisano jej jeszcze wartości. null to wartość przypisania. Może być przypisana do zmiennej jako reprezentacja braku wartości.;TypeScript;;true
What is proper "data" added to path definition in routing? (data property, route data);We use it to define data related to a given route. We can recover them in a component under a given route by providing ActivatedRoute. The data defined in this property cannot change during the application lifecycle.;Używamy jej do zdefiniowania danych powiązanych z danym routem. Możemy je odzyskać w componencie pod danym routem injectując ActivatedRoute. Dane zdefiniowane w tej propercji nie mogą się zmienić przez cykl życia aplikacji.;Angular;;false
What is concatMap and how does it work?;concatMap is a Higher-order mapping operator. It is used to support nested Observables. Each newly broadcast Observable source waits for the previously-broadcasted Observable to return the value of its internal Observable. The effect on the output is the list in the same order as on the input.;concatMap jest operatorem typu Higher-order mapping. Służy do obsługi zagnieżdżonych Observabli. Każdy nowo wyemitowany źródłowy Observable czeka, aż poprzedno-wyemitowany Observable zwróci wartość swojego wewnętrznego Observable. Efektem na wyjściu jest lista w takiej samej kolejności jak na wejściu.;Angular;;false
What are the ways to optimize front-end? (front-end optimization, application performance, app performance);1. Modularity 2. Implementation of OnPush change detection 3. Caching 4. Pipes instead of functions on the template, because pipes are only called when the value in the view changes, while the functions on the template are called every time anywhere the change detection system is started. 5. Using trackBy during ngFor loop, which will optimize the amount of code rendered when updating records in a table. 6. ServiceWorker 7. As we have an asynchronous event that we don't want to trigger changeDetection on all views, we can call it outside of NgZone: constructor (ngZone: NgZone) {zgZone.runOutsideAngular (() => {this._increaseProgress (() => { / * reenter the Angular zone and display done * / ngZone.run (() => {console.log ('Outside Done!')})})})};1. Modułowość 2.Odpowiednia implementacja detekcji zmian OnPush 3. Cachowanie 4. Pipy zamiast funkcji na templacie, ponieważ pipy wywołują się tylko kiedy wartość na widoku ulegnie zmianie, natomiast funkcje na templacie wywołują się każdym razem kiedy gdziekolwiek system detekcji zmian zostanie uruchomiony. 5. Używanie trackBy podczas pętli ngFor, który zoptymalizuję ilość renderowanego kodu przy aktualizacji rekordów w tabeli. 6. ServiceWorker 7. Jak mamy asynchroniczne wydarzenie, które nie chcemy żeby wywoływało changeDetection na wszystkich widokach możemy wywołać je poza NgZone: constructor(ngZone: NgZone){zgZone.runOutsideAngular(() => {this._increaseProgress(() => {/*reenter the Angular zone and display done*/ngZone.run(() => {console.log('Outside Done!')})})})};Angular;;true
What is Cross Site Scripting (XSS)?;If the user enters some input, which might be an unwanted script, and we display it later on the website, the unwanted script can run and do bad things. Angular treats the values ​​that are entered in the DOM as untrusted and will clean up unwanted elements from inputs containing e.g. a script block, so most of the time you do not need to do anything - Angular will take care of it for you.;Jeżeli użytkownik wpisze jakiś input, który może być niechcianym skryptem i my go później wyświetlimy na stornie to niechciany skrypt może isę uruchomić i zrobić złe rzeczy. Angular traktuje wartości, które są wpisane  w DOM jako niezaufane i oczyści niechciane elementy z inputów zawierających np. blok skryptowy, więc przez większość czasu nie trzeba nic robić - Angular zajmie się tym za nas.;Angular;;true
What are selectors?;Selectors are functions used to retrieve specific parts (Slices) of a state.;Selektory są funkcjami używanymi do pobierania określonych części (Slice'ów) stanu.;Angular;;false
When does DOM reflow occur?;DOM reflow occurs when you insert, move, update, remove, and animate the elements in the DOM as well as when you modify content on the page and change style.;DOM reflow występuje, gdy wstawiasz, przenosisz, aktualizujesz, usuwasz i animujesz elementy w DOM, a także gdy modyfikujesz zawartość strony i zmieniasz styl.;CSS;;true
Can only virtual methods be overwritten?;Only virtual methods and properties, unless the class only has a method definition with the word abstract, then we have to override.;Tylko wirtualne metody i propercje, chyba, że klasa ma zadeklarowaną tylko definicję metody ze słowem abstract, to wtedy musimy zrobić override.;OOP;;false
How does waitForAsync work?;waitForAsync tells Angular to run code in a dedicated test zone that captures all promises. Then we can use whenStable command on the component's fixture and as soon as the state is stable - all asynchronous operations will be resolved.;waitForAsync daje znać Angularowi, żeby uruchomić kod w dedykowanym testowym obszarze (zone), które przechwytuje wszystkie promisy. Następnie komendą whenStable na fixture componentu możemy operować jak już stan będzie stabilny - wszystkie operacje asynchroniczne będą resolved.;Testing;;true
What are browser Web APIs? (WebAPI);These are mechanisms provided by the browser, with the help of which we have additional functionalities, i.e. asynchronous JavaScript. Calle for Web API are added to Web API Container from Call Stack. These calls remain inside the Web API Container until they are completed, then they go to the Callback Queue.;To mechanizmy dostarczane przez przeglądarkę, za pomocą których mamy dodatkowe funkcjonalności, tj. asynchroniczność JavaScripta. Calle do Web API  są dodawane do Web API Container'a z Call Stacku. Te calle pozostają wewnątrz Web API Container'a do momentu ich zakończenia, wtedy trafiają na Callback Queue.;JavaScript;;true
Explain Container Components and Presentation Components.;Container Components are components that collect data from Store and pass it down to Presentation Components. All they do is subscribe to Store and dispatch certain actions based on the broadcast events from Presentation Components. The use of the OnPush change detection method is very suitable here, with a significant improvement in performance, and the overall syntax of the components is clearer and divided into responsibilities.;Container Components są komponentami, które zbierają dane ze Stora i przekazują je niżej do Presentation Components. Wszystko co robią to subskrybują do Stora i na podstawie wyemitowanych eventów z Presentation Componentów dispatchują określone akcje. Bardzo pasuje tutaj użycie metody detekcji zmian OnPush, co idzie ze znaczną poprawą wydajności oraz ogólna składnia komponentów jest bardziej przejrzysta i podzielona na obowiązki.;Angular;;false
Tell me about the directives in Angular.;Directives are custom HTML elements or attributes that are used to extend HTML. There are three types of directives: 1. Component directives - a directive with a template. 2. Structural directives - change the DOM layout and add or remove DOM elements, eg ngIf, ngFor, ngSwitch. 3. Attributes directives - change the look or behavior of an element, eg ngStyle.;Dyrektywy są to customowe HTML elementy albo atrybuty, używane do rozszerzenia HTMLa. Są trzy typy dyrektw: 1. Dyrektywy Componenty - dyrektywa z templatem. 2. Dyrektywy strukturalne - zmieniają DOM layout i dodają lub usuwają DOM elementy, np. ngIf, ngFor, ngSwitch. 3. Dyrektywy atrybuty - zmieniają wyghląd albo zachowanie elementu, np. ngStyle.;Angular;;true
What is Renderer2?;It is an Angular service that allows you to track and manipulate items in view without directly touching the DOM.;Jest to serwis w Angularze, który pozwala na śledzenie i manipulację elementami na widoku bez potrzeby bezpośrednego dotykania DOM.;Angular;;true
What is the difference between inline, embedded and external style sheets?;Inline Style Sheet is used in a specific HTML Tag and is used to style only that HTML Element. Embedded Style Sheets are put between the <head>...</head> tags within <style> element. This applys the style to all the pages within our website. With an external style sheet, we include a reference to the external style sheet file inside the <link> element, inside the <head> section.;Inline Style Sheet jest używany w Tagu HTML i służy do stylizowania tylko tego Elementu HTML. Embedded Style Sheets są umieszczane między znacznikami <head>...</head> w elemencie <style>. Stosuje to styl do wszystkich stron w naszej aplikacji. W zewnętrznym arkuszu stylów dołączamy odniesienie do zewnętrznego pliku arkusza stylów wewnątrz elementu <link>, wewnątrz sekcji <head>.;CSS;;true
How is a CSS selector used?;With a CSS selector, we can choose the content we want to style in HTML document. CSS selector is selecting HTML elements based on their class, id, type, etc.;Za pomocą selektora CSS możemy wybrać treść, którą chcemy stylizować w dokumencie HTML. Selektor CSS wybiera elementy HTML na podstawie ich klasy, identyfikatora, typu itp.;CSS;;true
What are the priorities for CSS conflict resolution? (CSS conflict, CSS priority);Highest priority has !important, then inline styles -> IDs -> Classes, pseudo-classes, attrubute -> Elements, pseudo-elements;Największy priorytet ma !import, następnie inline styles -> IDs -> Classes, pseudo-classes, attrubute -> Elements, pseudo-elements;CSS;;true
Explain how the ::after pseudo-class works.;The new elementB defined in elementA::after is treated as the child of element, so height:100% will be 100% of the height of elementA.;Nowy elementB definiowany w elementA::after jest traktowany jako child elementuA więc height: 100% będzie miało 100% wysokości elementuA.;CSS;;false
Why don't we create one SharedModule for the entire application?;SharedModule cannot be an all-in-one module. This is a common mistake among Angular Developers - one SharedModule with all shared Components is created at the same level. If each shared Component does not have its own module then its dependencies are directly in the SharedModule. Very quickly the number of Components in a SharedModule will be too large and unreadable. Ultimately, it turns out that SharedModule is a list of all Components shared across the entire application, and it is not possible to use a separate Component without importing the entire SharedModule. Admittedly, these dependencies are simple and clear for Angular, and the application does not grow many times over such a SharedModule architecture. Angular imports the SharedModule only once and identifies exactly which Component we need in our feature Module, but we want our feature Module to be transparent also for the developer. For this to happen, we only need to import a specific Component instead of the entire SharedModule.;SharedModule nie może być all-in-one modułem. Jest to typowy błąd wśród Angular Developerów - jeden SharedModule ze wszystkimi shared Componentami jest tworzone na tym samym poziomie. Jeżeli każdy shared Component nie ma swojego własnego modułu wtedy jego dependencies znajdują się bezpośrednio w SharedModule. Bardzo szybko ilość Componentów w SharedModule będzie zbyt duża i nieczytelna. Ostatecznie wychodzi na to, że SharedModule jest listą wszystkich Componentów dzielonych w całej aplikacji i nie jest możliwe użycie oddzielnego Componentu bez importowania całego SharedModule. Co prawda dla Angulara te zależności są proste i jasne, i aplikacja nie rośnie wielokrotnie przez taką architekturę SharedModule. Angular importuje SharedModule tylko raz i identyfikuje dokładnie jakiego Componentu potrzebujemy w swoim feature Module, jednak chcemy, żeby nasz feature Module przejrzyste informacje również dla developera. Żeby tak się działo musimy importować tylko konkretny Component zamiast całego SharedModule.;Angular;;true
What is Service Worker? (Service Worker definition);Simply put, a service worker is a script that runs in the browser and manages the caching of the application. Service workers intercept outbound HTTP requests created by the application and can choose how to respond to them. For example, they can query a local cache and deliver a cached response if one is available. Unlike other scripts in the application, Service Worker is preserved when you close a tab. The same instance of Worker Servers is shared between tabs of the same application and intercepts requests from all these tabs. For security reasons, Service Worker does not see requests from other applications running in the same browser and works only over HTTPS (except localhost).;Mówiąc najprościej, service worker jest skryptem, który działą w przeglądarce i zarządza cachowaniem aplikacji. Service workery przechwytują wychodzące requesty HTTP stworzone przez aplikację i mogą wybrać w jaki sposób na nie zareagować. For example, they can query a local cache and deliver a cached response if one is available. W przeciwieństwie do innych skryptów w aplikacji, Service Worker is zachowany po zamknięciu zakładki. Ta sama instancja Serwice Workera jest dzielona pomiędzy zakładkami tej samej aplikacji i przechwytuje requesty z tych wszystkich zakładek. Z powodów bezpieczeństwa Service Worker nie widzi requestów z innych aplikacji działających w tej samej przegladarce i działa tylko po HTTPS (z wyjątkiem localhosta).;Angular;;true
What is VH/VW (viewport height/ viewport width) in CSS?;VH and VW are CSS units used to measure viewport height and viewport width respectively in percentage form in the responsive design techniques. E.g. If the height of the browser is 1000px, then VH is 1/100 of the height of the viewport that is 1000px*(1/100) = 10px, which is the height of the browser.  The same applies to VW (viewport width).;VH i VW to jednostki CSS używane do mierzenia odpowiednio wysokości i szerokości viewportu w formie procentowej w technikach Responsive Desin. Np. Jeśli wysokość przeglądarki wynosi 1000px, wtedy VH jest 1/100 wysokości widocznego obszaru, czyli 1000px*(1/100) = 10px, czyli wysokość przeglądarki. To samo dotyczy VW (szerokość rzutni).;CSS;;true
How does the any type work?;Any is a dynamic type. It tells the compiler not to check the type of a given variable. Represents all possible JavaScript types. Each type is assignable to any.;Any jest typem dynamicznym. Mówi on kompilatorowi, żeby nie sprawdzał typu danej zmiennej. Reprezentuje wszystkie możliwe typy JavaScript. Każdy typ jest przypisywalny do any.;TypeScript;;true
Tell us something about CSS3.;CSS3 provides many graphics-related characteristics are introduced in CSS3 like box-shadow, Border-radius, and flexbox. A user can create precise multiple background images using properties like background-position, background-repeat, and background-image styles.;CSS3 zapewnia wiele cech związanych z grafiką zostało wprowadzonych do CSS3, takich jak box-shadow, Border-radius i flexbox. Użytkownik może tworzyć wiele precyzyjnych obrazów tła, korzystając z takich właściwości, jak style background-position, background-repeat i background-image.;CSS;;true
What does the ngsw.json file contain?;It is built based on the ngsw-config.json configuration file. ngsw.json contains the hash table of the application files specified in the configuration file as well as all other information by which the Service Worker knows which files to update and cache.;Jest budowany na podstawie pliku konfiguracyjnego ngsw-config.json. ngsw.json zawiera tablicę hashy plików aplikacji określonych w pliku konfiguracyjnym, jak i wszystkie inne informacje, na których podstawie Service Worker wie, które pliki aktualizować i cachować.;Angular;;false
What is Mock?;The Mock definition overrides the dependency of the tested object. It is not used to check the behavior of a function or the return values ​​from function calls. It is used to check whether a function was called or not. If it is called, how many times it is called or what parameters are passed during the call.;Definicja Mocka zastępuje dependency testowanego obiektu. Nie służy do sprawdzania zachowania funkcji albo zwracanych wartości z wywołań funkcji. Jest używany żeby sprawdzić czy funkcja się wywołała czy nie.  Jeżeli się wywołuje to ile razy jest wywoływana lub jakie parametry są przekazywane podczas wywołania.;Testing;;true
What is Redux?;Redux is a pattern for managing the state of the application, NgRx is a popular library in Angular.;Redux jest wzorcem do zarządzania stanem aplikacji, w Angularze popularną biblioteką od tego jest NgRx.;Angular;;true
What is Lambda Expression? (What is Arrow Function);Lambda expression is a convenient way to define an anonymous function that can be assigned to a variable or passed as a parameter to a method.;Lambda expression to wygodny sposób na definionwanie anonimowej funkcji, która może być przypisana do zmiennej, albo przekazana jako parametr metody.;OOP;;true
Define gradients in CSS.;A property of CSS that allows displaying smooth transformation between two or more specified colors. The types of gradients are linear and radial.;Propercja CSS, która pozwala na wyświetlanie transformacji pomiędzy dwoma lub więcej określonymi kolorami. Rodzaje gradientów to linera i radial.;CSS;;true
What is an Object? (JavaScript Object);Objects are dictionary-like collections of keys and values. The keys have to be unique.;Obiekt to struktura słownikowa, kolekcja kluczy i wartości. Klucze muszą być niepowtarzalne.;JavaScript;;true
What is the ng-template directive and when is it useful?;Ng-template element is not displayed on the template by defulat. We display it conditionally or explicitly on the component template. If It can be used e.g. in case we want to create if-else on a view between two directives. Angular implicitly uses ng-template in the * ngIf, * ngFor, and * ngSwitch directives, so we actually use it all the time.;Ng-template jest elementem na templatcie komponenta wyświetlanym warunkowo. Jeżeli zadeklarujemy po prostu ng-template na widoku nie wyświetli nam się nic do czasu aż nie wywołamy pokazania zawartości tej dyrektywy. Może być używana np. w przypadku jeżeli chcemy stworzyć if-else na widoku pomiędzy dwoma dyrektywami. Angular niejawnie używa ng-template w dyrektywach *ngIf, *ngFor i *ngSwitch, więc tak naprawdę używamy jej cały czas.;Angular;;true
What is the difference between FormArray and FormGroup?;FormArray is a form of FormGroup. The main difference is that we serialize the FormArray to an array.;FormArray jest formą FormGroup. Główna różnica jest taka, że FormArray serializujemy do tablicy.;Angular;;false
Which is better @Injectable (providedIn: {module_name}) or proper providers in the decorator @NgModule ()?;It is preferable to use @Injectable (providedIn: {module_name}) because better optimization tools can do tree-shaking which removes sites not used by the application, resulting in smaller package sizes. If we use the proper providers in the decorator @NgModule (), our service will be included in the built package even if it is not used.;Lepiej jest używać @Injectable(providedIn: {module_name}), ponieważ narzędzia optymalizacyjne mogą lepiej wykonywać tree-shaking, które usuwa pliki nieużywane przez aplikację, co skutkuje mniejszymi rozmiarami pakietów. Jeśli użyjemy odpowiednich providerów w dekoratorze @NgModule(), nasza usługa zostanie uwzględniona w budowanym pakiecie, nawet jeśli nie jest używana.;Angular;;false
What is HttpClientTestingModule and HttpTestingController?;HttpClientTestingModule and HttpTestingController provides useful methods for checking http requests and providing mock responses for each request.;HttpClientTestingModule i HttpTestingController udostępniają przydatne metody do sprawdania requestów http i dostarczania mocków odpowiedzi dla każdego requestu.;Testing;;true
Describe Just-in-time Compilation and Ahead-of-time Compilatin.;In Just-in-time Compilatin, the entire application is sent to the browser along with the Angular code that is used to compile that application while it is running. We use this in the development environment because it makes it easier to implement functionality and debug the application, but it is a lot of extra stuff, unnecessary to download and execute, that we do not want in our production environment because it slows down the application. Ahead-of-time Compilation compiles the application before uploading it to production servers. This way compilation happens once and only the compiled application is sent to the browser, which saves time.;W Just-in-time Compilatin cała aplikacja jest wysyłana do przeglądarki razem z kodem Angulara, który jest używany do kompilacji tej aplikacji podczas jej działania. Używamy tego na środowisku developerski, ponieważ możemy przez to łatwiej implementować funkcjonalność i debudować aplikację, jednak jest to dużo dodatkowych rzeczy, niepotrzebnych do pobrania i wykonania, których nie chcemy na naszym produkcyjnym środowisku, ponieważ spowalnia aplikację. Ahead-of-time Compilation kompiluje aplikację przed przekazaniem jej na produkcyjne serwery. W ten sposób kompilacja zdarza się raz i tylko skompilowana aplikacja wysyłana jest do przeglądarki, co oszczędza czas.;Angular;;true
What is Code Splitting?;It is breaking code into batches or components (or just breaking code into parts) that can be loaded on demand or in parallel.;Jest to dzielenie kodu w paczki albo komponenty (albo na po prostu dzielenie kodu na części), które mogą być ładowane na rządanie albo równolegle.;Angular;;true
Describe how Subject, BehavioralSubject, ReplaySubject, and AsyncSubject work.;Subject sends data to subscribed observers. Any previously issued value is not sent to the new observer. BehavioralSubject sends the last value to a new observer. ReplaySubject sends all (or the specified amount) of previous values ​​to a new observer. AsyncSubject only sends the last value to the watchers after the upload is complete.;Subject wysyła dane do zasubskrybowanych obserwatorów. Żadna wcześniej wyemitowana wartość nie jest wysyłana do nowego obserwatora. BehavioralSubject wysyła ostatnią wartość do nowego obserwatora. ReplaySubject wysyła wszystkie (lub określoną ilość) wcześniejsze wartości do nowego obserwatora. AsyncSubject wysyła do obserwatorów tylko ostatnią wartość po zakończeniu przesyłu.;Angular;;false
What does the ngsw-config.json file do?;This is a configuration file that specifies the files and data urls that the Service Worker should cache and how to update the cached files and data. From this file, the CLI generates ngsw.json during build.;Jest to plik konfiguracyujny określający pliki i URLe z danymi, które Service Worker powinnien cach'ować i w jaki sposób aktualizować cach'owane pliki i dane. Na podstawie tego pliku CLI generuje ngsw.json podczas builda.;Angular;;false
What is Push API? (PushAPI);API that allows web applications to receive 'pushed' messages from the server, regardless of whether the web application is loaded or not. This allows developers to deliver asynchronous notifications and updates to the user who signed up for them, which results in better user involvement in new content.;API, dzięki któremu aplikacje webowe mają możliwość możliwość otrzymywania wiadomości 'pushowanych' z serwera, niezależnie czy aplikacja webowa jest załadowana lub nie. To pozwala developerom dostarczać asynchroniczne notyfikacje i aktualizacje do użytkownika, który się na nie zapisał, co skutkuje lepszym zaangażowaniem użyutkownika w nowy content.;Angular;;false
What is a fixture in Angular tests?;[write better] Component fixture is a test utility type that is going to help us to do common test operations such as obtaining an instance of the component, debugging component, etc.;[napisać lepiej]Fixture Componentu pomocniczy typ testowy, który pomaga nam w wykonywaniu ogólnym operacji testowych takich jak uzyskanie dostępu do instancu Componentu, debugowaniu componentu, itd.;Testing;;true
What is angular.json?;This is the file with the main configuration settings of applications and libraries in a solution.;To plik z głównymi ustawieniami konfiguracyjnymi aplikacji i bibliotek w solucji.;Angular;;true
What are the limitations of Event Binding?;1. We cannot react to events outside the Component's template, nor on the component itself (its selector - host). 2. We cannot dynamically subscribe or unsubscribe to the event.;1. Nie możemy reagować na eventy poza templatem komponentu, ani na samym komponencie (jego selektorze - host'cie). 2. Nie możemy dynamicznie zasubskrybować albo odsubskrybować eventu.;Angular;;false
What is callback?;A function that is provided to another piece of code, allowing that code to call it.;Funkcja dostarczana do innego fragmentu kodu, pozwalając aby ten kod mógł ją wywołać.;Angular;;true
Describe the dependency resolvency process in Dependency Injection.;Angular resolves a given token (let's say a service) in two steps: 1. Checks the ElementInjectors hierarchy 2. Checks the ModuleInjectors hierarchy. If the service is not found during the first phase, it moves to the second phase. If in the second phase it does not find a dependency, it throws an exception or returns null if the parameter was specified with the @Optional() decorator. Angular resolves the first element it finds during this process.;Angular resolvuje dany token (powiedzmy serwis) w dwóch fazach: 1. Sprawdza hierarchię ElementInjectorów 2. Sprawdza hierarchię ModuleInjectorów. Kiedy podczas pierwszej fazy serwis nie zostanie znaleziony przechodzi do drugiej fazy. Jeżeli w drugiej fazie nie znajdzie zależności to wyrzuca wyjątek lub zwraca null jak parametr był określony dekoratorem @Optional(). Angular resolvuje pierwszy element jaki znajdzie poczas tego procesu.;Angular;;true
What is switchMap and how does it work?;switchMap is an operator of the Higher-order mapping type. It is used to support nested Observables. If a nested Observable is in progress and a new source Observable arrives, it cancels the previous reference and switches to the internal Observable of the current source Observable.;switchMap jest operatorem typu Higher-order mapping. Służy do obsługi zagnieżdżonych Observabli. Jeżeli zanieżdzony Observable jest w trakcie wywoływania, a przyjdzie nowy źródłowy Observable to anuluje wcześniejsze odwołanie i przełączy się na wewnętrzną Observable aktualnego źródłowego Observable.;Angular;;false
What is Transport Protection?;Transport Protection security is a way of secure requests between front-end and back-end, or between back-end APIs. The way to do this is to use HTTPS everywhere. For the front-end, you just have to make sure that all back-end addresses have the "https" prefix.;Transport Protection security jest sposobel bezpiecznych requestów pomiędzy front-endem, a back-endem albo pomiędzy back-endowymi API. Sposobem na to jest używanie HTTPS wszędzie. Dla front-endu trzeba się po prostu upewnić, że wszystkie adresy do back-endu mają prefix "https".;Angular;;true
What are Web Workers? (WebWorkers);Web Workers allow you to run computationally heavy tasks on a background thread, freeing the main thread to update the interface. If the application performs a lot of calculations (such as CAD drawing generation or heavy geometric calculations) using Web Workers can help in application performance.;Web Workery pozwalają na uruchomienie ciężkich obliczeniowo zadań w wątku w tle, uwalniając główny wątek żeby zaktualizować interface. Jeżeli aplikacja wykonuje dużo obliczeń  (jak generowanie CAD drawings albo ciężkie geometryczne kalkulacje) użycie Web Workerów może pomóc w wydajności aplikacji.;Angular;;true
What is Stub?;The definition of Stub replaces the dependency of the test object. It is an object whose behavior we control. When we call a certain method in Stub, we control in our test what value this method returns.;Definicja Stuba zastępuje dependency testowanego obiektu. Jest to obiekt, którego zachowanie kontrolujemy. Jak wywołamy pewną metodę w Stubie kontrolujemy w naszym teście jaką wartość ta metoda zwraca.;Testing;;true
What operations does SwUpdate support?;SwUpdate: 1. Raises an event informing about an available update - when it downloads it and when it is cached. 2. It allows us to call a function that checks for updates. 3. Raises an event informing us when we are in Unrecoverable State.;SwUpdate: 1. Wznosi event informujący o dostępnej aktualizacji - kiedy ją pobiera i kiedy jest zcacheowana. 2. Pozwala nam wywołać funkcję sprawdzającą dostępność aktualizacji. 3. Wznosi event informujący nas kiedy jesteśmy w stanie Unrecoverable State.;Angular;;false
What are RxJS operators? (RxJS functions);The operators in RxJS are the functions that we use in the sequence called on the observable of the pipe () function. We divide the operators into Creation (of, throwError), Transformation (map, mergeMap), Filtering (filter, take), Error Handling (catchError), Utility (tap, delay).;Operatory w RxJS to funkcje, których używamy w sekwencji wywołanej na observablu funkcji pipe(). Operatory dzielimy na Creation(of, throwError), Transformation(map,mergeMap), Filtering (filter, take), Error Handling(catchError), Utility(tap, delay);Angular;;true
What is Largest Contentful Paint? (What is LCP);LCP is a measure of page speed. It tells us how long it takes for the main content of the page to be out;LCP jest miarą prędkości strony. Mówi nam jak długo potrzeba żeby główny content strony się załadował.;JavaScript;;true
In what order are the routes of the imported modules loaded?;First, we load the routes of the imported modules, and only then the paths defined in the given module.;Najpierw ładujemy ścieżki zaimportowanych modułów, a dopiero na końcu zdefiniowaną w danym module.;Angular;;false
How does Routing work in Angular?;1. The router starts up when it sees a change in the URL. 2. The router looks at an array of configured routes, comparing the URL's segment with each one. If Router is able to match the URL, it continues with the matched route. 3. The router checks the Guards to see if we are able to go to the given route. 4. Component initialization. 5. Displaying the Template in the <router-outlet> directive. 5. The router is waiting for the next URL change.;1. Router zaczyna działać kiedy widzi zmianę w URL. 2. Router patrzy na tablicę skonfigurowanych ścieżek, porównując URL segmenty z każdą z nich. Jeżeli Router jest w stanie dopasować URL kontynuuje on swoje działanie z dopasowaną ścieżką. 3. Router sprawdza Guardy żeby sprawdzić czy można jesteśmy w stanie przejść na daną ścieżkę. 4. Inicjalizacja Componentów. 5. Wyświetlenie Template'u w dyrektywie <router-outlet>. 5. Router czeka na następną zmianę URL.;Angular;;true
Describe ElementInjector in Angularze.;Angular creates an ElementInjectory implicitly on every DOM element. We specify it in the 'providers' in @Component() or @Directive() decorators. Provided service is available to component instances or to its children, if they do not have a provided service in their ElementInjectors.;Angular tworzy ElementInjectory skrycie (implicitly) na każdym DOM elemencie. Określamy go w propercji providers w @Component() albo @Directive(). Providowany serwis jest dostępny dla instancji komponentu lub dla jego dzieci, jeżeli nie mają one zprovidowanego serwisu w ich ElementInjectorach.;Angular;;false
How does position: sticky work?;As long as the parent's content of the element with position: sticky is visible on the screen, the element moves relatively to it, not exceeding the distance specified in top, right, bottom, left with respect to the visible document. When the parent's content disappears from the screen, the sticky element disappears with it.;Póki content parenta elementu z position: sticky jest widoczny na ekranie, element porusza się razem z nim nie przekraczając odległości określonej w top, right, bottom, left względem względem widocznego dokumentu. Kiedy content parenta znika z ekranu element sticky znika razem z nim.;CSS;;false
What is the order of processing Guards?;canDeactivate -> canLoad -> canActivateChild -> canActivate -> resolve;canDeactivate -> canLoad -> canActivateChild -> canActivate -> resolve;Angular;;true
What is SASS?;Sass (.scss) is a CSS preprocessor, a CSS extension that adds more mechanisms and syntax capabilities to the core CSS language.;Sass jest preprocessorem CSS, rozszerzeniem CSS, które dodaje więcej mechanizmów i możliwości skłądniowych do podstawowego języka CSS.;CSS;;true
What is Margin Collapsing?;If we have two box models next to each other and they have margins, then these margins overlap and the larger margin wins.;Jeżeli mamy dwa modele pudełkowe obok siebie i mają one marginesy, to te marginesy nachodzą na siebie i wygrywa większy margines.;CSS;;false
Why could we build on microfrontends architecture? (why microfrontends);1. Migrating a massive application from one technology to another. 2. If we want to combine applications written in different technologies.;1. Migrowanie ogromnej aplikacji z jednej technologii na drugą. 2. Jeżeli chcemy połączyć ze sobą aplikacje napisane w różnej technologii.;Angular;;false
What does ng-content do? (What is ng-content);When the ComponentA has <ng-content> in it's template, and we use it's selector (host directive), let's say, in ComponentB, then the content inside that selector will be displayed in <ng-content> element on ComponentA template.;Kiedy ComponentA ma zdefiniowany element <ng-content> w swoim templacie, i użyjemy jego selektora, powiedzmy, w ComponencieB, wtedy zawartość wewnątrz tego selektora będzie wyświetlona w elemencie <ng-content> na templacie ComponentuA.;Angular;;false
What is 'unrecoverable state' in Service Worker?;In some cases, the cached application used by the Service Worker may have a broken state that cannot be recovered without a full page reload. Example steps for this case: 1. The user runs the cached application consisting of index.html, main<main-hash-1>.js, lazy-chunk.<lazy-hash-1>.js. 2. The user closes the application and does not open it for some time. 3. Meanwhile, the application is updated on the server with index.html, main<main-hash-2>.js, lazy-chunk<lazy-hash-2>.js. Hashes are different because they are files with new content, old content is not available. 4. In the meantime, the user's browser decides to remove, for example, lazy-chunk<lazy-hash-1>.js from the cache. Browsers can do this if in order to obtain disk space. 5. The user opens the application again. Service Worker only provides index.html and main <main-hash-1>.js. 6.When it needs to load lazy-chunk<lazy-hash-1>.js Service Worker will not be able to find the required file in the cache (because the browser deleted the file to gain memory), nor is it able to get it from the server, because there is only the latest version of the file on it. In this case, the Service Worker informs us about it by raising UnrecoverableStateEvent.;W niektórzych przypadkach aplikacja w cachu używana przez Service Workera może mieć zepsuty stan, który nie może być odzyskany bez pełnego przeładowania strony. Przykładowe kroki takiego przypadku: 1. Użytkownik uruchamia aplikację, która jest cachowana, składająca się z index.html, main<main-hash-1>.js, lazy-chunk.<lazy-hash-1>.js. 2. Użytkownik zamyka aplikację i nie otwiera jej przez jakiś czas. 3. W międzyczasie aplikacja jest zaktualizowana na serwerze z plikami index.html, main<main-hash-2>.js, lazy-chunk<lazy-hash-2>.js. Hashe są inne ponieważ są to pliki z nową zawartością, stara zawartość nie jest dostępna. 4. W międzyczasi przeglądarka użykownika decyduje się usunąć np. lazy-chunk<lazy-hash-1>.js z cachu. Przeglądarki mogą to robić jeżeli w celu uzyskania miejsca na dysku. 5. Użytkownik otwiera aplikację ponownie. Service Worker dostarcza tylko index.html i main<main-hash-1>.js. 6. Kiedy nadejdzie potrzeba załadowania lazy-chunk<lazy-hash-1>.js Service Worker nie będzie w stanie znaleźć wymaganego pliku w cache (ponieważ przeglądarka usunęła pliku w celu uzyskania pamięcy), ani nie jest w stanie pozyskać go z serwera, poonieważ jest na nim już tylko najnowsza wersja pliku. W takim przypadku Service Worker informuje nas o tym wznosząc UnrecoverableStateEvent.;Angular;;false
What is inheritance?;Mechanism of sharing functionality between classes. A class can inherit from another class, which means that in addition to its attributes and functions, it also has those derived from the base class. Reduces code duplication.;Mechanizm współdzielenia funkcjonalności między klasami. Klasa może dziedziczyć po innej klasie, co oznacza, że oprócz swoich atrybutów i funkcji posiada również te pochodzące z klasy bazowej. Redukuje powielanie kodu.;OOP;;true
What is Composition?;Composition is simply when one object consists of other objects.;Z kompozycją mamy doczynienia, kiedy obiekt składa się z innych typów, po prostu. W kompozycji jeden obiekt posiada inny obiekt, który jest jego składową. Jest to szczególny przypadek agregacji, w którym obiekty składowe nie mogą istnieć bez obiektu głównego. Np. obiekt człowiek posiada obiekty głowa, ręka, etc.;OOP;;true
What is <base href="/"> in index.html?;It tells Angular in which folder our application is stored. If our application were kept in a directory, e.g. tech-events, this element would look like <base href="/tech-events">;Mówi Angularowi w jakim folderze na naszej stronie trzymana jest nasza aplikacja. Jeżeli nasza aplikacja byłaby trzymana w katalogu np. tech-events to element ten wyglądałby <base href="/tech-events">;Angular;;false
When do we create a separate Component?;When the item: 1. Has its own logic to interact with the user. 2. Has a complicated layout or animations. 3. Has methods that may distract from understanding the parent Component's logic.;Kiedy element: 1. Posiada własną logikę do interakcji z użytkownikiem. 2. Ma skomplikowany layout lub animacje. 3. Posiada metody, które mogą odwrócić uwagę od zrozumienia logiki Componentu rodzica.;Angular;;true
What is DOCTYPE in HTML?;All HTML documents must start with a <!DOCTYPE> declaration. The declaration is not an HTML tag. It is an "information" to the browser about what document type to expect. In HTML5, the declaration is simple: <!DOCTYPE html>. Older documents are HTML4 or XHTML.;Wszystkie dokumenty HTML muszą zaczynać się od deklaracji <!DOCTYPE>. Deklaracja nie jest tagiem HTML. Jest to "informacja" dla przeglądarki o tym, jakiego typu dokumentu się spodziewać. W HTML5 deklaracja jest prosta: <!DOCTYPE html>. Starsze dokumenty to HTML4 lub XHTML.;HTML;;true
What are the benefits of HTML? (html benefits);1. Compatibility with all web browsers and devices. 2. Cleaner code for developers. 3. Native support for multimedia content. 4. Quicker load times due to offline storage cache. 5. Introduction of geolocation.;1. Kompatybilność ze wszystkimi przeglądarkami internetowymi i urządzeniami. 2. Czystszy kod dla programistów. 3. Natywna obsługa treści multimedialnych. 4. Szybsze czasy ładowania dzięki pamięci podręcznej w trybie offline. 5. Wprowadzenie geolokalizacji.;HTML;;false
What is flex? (display: flex, display flex);Flex is a special display property value, after which the element becomes a so-called flex-container, and the elements inside with flex-items, which allows us to apply special properties to them.;'flex' to specjalna wartość właściwości propercji 'display', po której element staje się tak zwanym flex-containerem, a elementy wewnątrz flex-itemami, co pozwala nam zastosować do nich specjalne właściwości.;CSS;;true
What is an HTML tag and attribute? (HTML Tag, HTML Attribute);HTML tags used are to place the content and format the pages. They always defined between angle brackets (<, >). For example, <h1>text</h1>. By HTML element we describe section on the web page - opening tag, closing tag, and content between them. HTML attributes are properties we can add to an HTML tab that alters the way a tag behaves or the way it is displayed. For example 'disabled' attribute.;Użyte znaczniki HTML służą do umieszczania treści i formatowania stron. Są one zawsze definiowane między nawiasami ostrymi (<, >). Na przykład <h1>tekst</h1>. Elementem HTML opisujemy sekcję na stronie internetowej - tag otwierający, tag zamykający i zawartość pomiędzy nimi. Atrybuty HTML to właściwości, które możemy dodać do zakładki HTML, które zmieniają sposób zachowania tagu lub sposób jego wyświetlania. Na przykład atrybut disabled.;HTML;;true
What are the states of the form?;1. valid - when the form is validated. 2. invalid - when there are errors on the form. 3. pristine - when the form has not been modified. 4. dirty - when the form was modified. 5. untouched - when the form has not been touched 6. touched - when the form has been touched.;1. valid - kiedy formularz przechodzi validacje. 2. invalid - kiedy są błędy na formularzu. 3. pristine - kiedy formularz nie był modyfikowany. 4. dirty - kiedy formularz był modyfikowany. 5. untouched - kiedy formularz nie bym ruszony 6. touched - kiedy formularz był ruszony.;Angular;;false
Describe class binding in Angular.;We use proper function [ngClass] = "class1 class 2", [ngClass] = ['class1', 'class2'], [ngClass] = "{class1: 1 === 1, class2: 'asd' === 'asd '} ", [ngClass] =" getStartTimeClass () ". If we already have a class defined in the html element, then the classes from the [ngClass] attribute will be added to this class.;Używamy propercji [ngClass]="class1 class 2", [ngClass]=['class1','class2'], [ngClass]="{class1: 1===1,class2: 'asd'==='asd'}",[ngClass]="getStartTimeClass()". Jeżeli mamy już zdefiniowaną klasę w lemencie html to klasy z atrubutu [ngClass] zostaną dodane do tej klasy.;Angular;;false
What are state slices?;The entire state object is divided into parts called slicas.;Cały obiekt stanu podzielony jest na części, które nazywane są slicami.;Angular;;false
What is Store?;Store is a state container in NgRx. It is literally a Json object that holds the state of the application. We can think of it as a local database in client's memory.;Store jest kontenerem stanu w NgRx. Jest dosłownie obiektem Json'owym, który przetrzymuje stan aplikacji. Możemy o nim myśleć jak o lokalnej bazie danych w pamięci clienta.;Angular;;false
Describe @Inject() and @Injectable().;@Inject(token) is a manual mechanism for letting Angular know that a parameter must be injected. We place it before variable we want to inject and Angular is searching for the token in various injectors. @Injectable() lets Angular know that a class can be used with the Dependency Injection.;@Inject(token) to ręczny mechanizm informujący Angulara, że ​​parametr musi zostać wstrzyknięty. Umieszczamy go przed zmienną, którą chcemy wstrzyknąć, a Angular szuka tokena w różnych injectorach w swojej procedurze wyszukiwania zależności. @Injectable() pozwala Angularowi wiedzieć, że klasa może być używana z wstrzykiwaniem zależności.;Angular;;false
How does Lazy Loading work?;First, all imported modules are run, lazy loaded modules are loaded from the back-end only when we want to access them.;Najpierw uruchamiane są wszystkie zaimportowane moduły, pozostałe zaciągane są z back-endu w tle.;Angular;;true
What is NgZone? (Angular zone, zone.js);It is a wrapper for the zone.js library. Intercepts and tracks asynchronous operations such as setTimeout, setInterval, Promise.then, XMLHTTP Request, and DOM events such as click(), keyDown, keyUp, submit, addEventListener. When one of these operations happens, Angular calls changeDetection.;Jest to wrapper dla biblioteki zone.js. Przechwytuje i śledzi operacje asynchroniczne tj. setTimeout, setInterval, Promise.then, XMLHTTP Request, oraz DOM eventy tj. click(), keyDown, keyUp, submit, addEventListener. Kiedy jedna z tych operacji się zdarzy Angular wywołuje changeDetection.;Angular;;true
What is the difference between providers and viewProviders?;The provision of providers makes the provided value available to a given component or its children, while viewProviders causes that only the given component can use it (or the content defined in <ng-content> invoking that component, but that's on the sidelines).;Propercja providers powoduje, że providowana wartość jest dostępna dla danego komponentu albo dla jego dzieci, natomiast viewProviders powoduje, że tylko dany komponent może z niej korzystać (albo zawartość zdefiniowana w <ng-content> wywołania tego komponentu ale to już na marginesie).;Angular;;false
What is Map object?;Map is a collection of data associated with key data, a dictionary structure, just like Object, but in the case of Map the key can be any type. Map also maintains the order of elements, Object does not.;Map to kolekcja danych porzypisanych do danych kluczy, struktura słownikowa, tak samo jak Object, jednak w przypadku Map klucz może być każdym typem. Map również zachowuje kolejność elementów, Object nie.;Angular;;true
What are End to End tests?;End to End tests are tests that are run on a running application with a running database and the server. Thanks to them, we can test whether our application works properly as a whole.;End to End testy są to testy, które są uruchamiane na działającej, uruchomionej aplikacji z działającą bazą danych, serwerem. Dzięki nim możemy przetestować czy nasza aplikacja działa poprawnie jako całość.;Testing;;true
What is Callback Queue?;This is the FIFO queue that contains all callback functions from asynchronous operations in the order in which the operations were completed.;To kolejka FIFO, która zawiera wszystkie callback funkcje z operacji asynchronicznych w kolejności w jakiej operacje te zostały ukończone.;JavaScript;;true
What are the types of forms in Angular? Describe them. (form types);1. Reactive Forms provide direct access to the form object in the Component class. Compared to template-driven forms, they are more robust, scalable and reusable. 2. Template-driven Forms create a form object on a view implicitly. they rely on directives in the template to create and manipulate the hidden form model. They are useful for adding a simple form to an application. They don't scale and with a larger form they are hard to scale and maintain.;1. Reactive Forms zapewniają bezpośredni dostęp do obiektu formularza w klasie Component. W porównaniu z Template-driven Forms są bardziej niezawodne, skalowalne i wielokrotnego użytku. 2. Template-driven Forms tworzą obiekt formularza w widoku niejawnie. Opierają się na dyrektywach w szablonie, aby tworzyć i manipulować ukrytym modelem formularza. Przydają się przy dodawaniu do aplikacji prostego formularza. Nie skalują się, a przy większym formularzu są trudne do utrzymania.;Angular;;true
How does the creation of an Observable differ from the operator "of" from "from"?;A different structure for a table. In of ([table]), if we specify the tables, it will emit the entire table once, we have to give the Spread Operator (...) how we want to emit each element of the table separately. In the case of the from operator ([table]), the observable will emit each table element separately.;Inna struktura w przypadku tabeli. W of([tabela]) jak podamy tabele to wyemituje nam całą tabelę raz, musimy podać Spread Operator (...) jak chcemy emitować każdy element tabeli oddzielnie. W przypadku operatora from([tabela]) observable będzie emitowała każdy element tabeli oddzielnie.;Angular;;false
What are the recommended Modules?;1. App Module. 2. Core Module - holds services and components of the entire application level. 3. Shared Module - shared components, directives, pipes. 4. Feature Modules - services, components, directives, level pipes of a given module.;1. App Module. 2. Core Module - przetrzymuje serwisy i komponenty poziomu całej aplikacji. 3. Shared Module - dzielone komponenty, dyrektywy, pipe'y. 4. Feature Moduły - serwisy, componenty, dyrektywy, pipy poziomu danego modułu.;Angular;;true
What is ngsw-worker.js?;This is the script of Service Wroker itself that is used during it's registration. This file is the same with every build as it is copied by the CLI straight from node-modules. The file will be the same until the new version of Angular Service Worker is updated.;Jest to skrypt samego Service Wrokera, używany podczas rejestracji. Plik ten jest taki sam z każdym buildem, ponieważ jest kopiowany przez CLI prosto z node-modules. Plik będzie taki sam do czasu aktualizacji nowej wersji Angular Service Workera.;Angular;;false
What are the types of ViewEncapsulatin in Angular?;ViewEncapsulation.None - without any encapsulation, styles are imposed on the entire document, ViewEncapsulation.Emulated - Shadow DOM emulation, works the same as Shadow DOM but does not use native Shadow DOM, ViewEncapsulation.Native - native Shadow DOM.;ViewEncapsulation.None - bez żadnej enkapsulacji, style są narzucane na cały dokument, ViewEncapsulation.Emulated - emulacja Shadow DOM'u, działa tak samo ale jak Shadow DOM ale nie używa natywnego Shadow DOM'u, ViewEncapsulation.Native - natywny Shadow DOM.;Angular;;false
What should you remember about performance in CSS animations?;That it's best to only animate two different properties - opacity and transform. Browsers are optimized for this. But with transoform we can do a lot.;Że najlepiej jest animować tylko twie różne propercje - opacity i transform. Przeglądarki są zoptymalizowane pod tym kątem. Ale za pomocą transoform możemy zrobić naprawdę dużo.;CSS;;false
When OnPush triggers change detection?;1. When reference to the property with Input() decorator changes. 2. Property/EventEmitter with decorator Output() or DOM event emits. 3. The async pipe receives the event. 4. Change detection is manually invoked by ChangeDetectorRef.;1. Kiedy zmienia się referencja obiektu pod propercją Input(). 2. Propercja/EventEmitter z dekoratorem Output() lub zdarzenie DOM emituje. 3. Async pipe odbiera zdarzenie. 4. Wykrywanie zmian jest wywoływane ręcznie przez ChangeDetectorRef.;Angular;;true
How fakeAsync works?;Mechanism that wraps our test in the fakeAsync zone which detects the presence of asynchronous operations defined in it such as setTimeouts, setIntervals, requests, etc. and wait for all of those operations to complete before completes the test. fakeAsync zone is going to replace the browser default implementation of the, for example setTimeout function, with it's own custom function that simulates the passage of time. So inside fakeAsync zone, in order to push the clock forward, we are going to use function tick() or flush() to execute all timers that has been queued. We can say thhat fakeAsync helps us with testing of asynchronous code in synchronous way.;Mechanizm, który wrapuje nasz test w fakeAsync zone, które wykrywa obecność asynchronicznych operacji zdefiniowanych wewnątrz, tj. setTimeout, setInterval, zapytania, itd. i czeka aż wszystkie te operacje się skończą zanim zakończy test. fakeAsync zone zastępuje domyślne przeglądarkowe implementacje jak np. funkcji setTimouet, swoją własną funkcją symulującą upływ czasu. Więc wewnątrz fakeAsync zone, żeby przewinąć zegarek do przodu, użyjemy funkcji tick(), a do wykonania wszystkich operacji asynchronicznych flush(), która automatycznie wykonuje wszystkie zakolejkowane operacje. Można powiedzieć, że fakeAsync pomaga nam w testach asynchronicznego kodu w sposób synchroniczny.;Testing;;true
What functions does the Observer take?;The Oberver object takes the function 1. next() - telling what to do with the next data that will trigger. 2. error() - called in the event of an error. 3. complete() - executed when the transmission is complete.;Obiekt Obervera przyjmuje funkcje 1. next() - mówiącą o tym co zrobić z następnymi danymi, które przycodzą. 2. error() - wywołującą się w przypadku błedu. 3. complete() - wykonującą się w przypadku skończenia nadawania.;Angular;;false
How does Service Worker improve performance? (Service Worker performance, performance Service Worker);If we have a registered ServiceWorker, the application is downloaded and cached at the first start. At each subsequent launch, the application is immediately launched from the cache, while a query for the hash file of all application files (ngsw.json) is sent in the background and on this basis the need to update the application version in the cache is checked. The hash file is generated from the ngsw-config.json file, which in turn is generated from the CLI when building the application.;Jeżeli mamy zarejestrowanego ServiceWorkera to przy pierwszym uruchomieniu aplikacja jest pobierana i cacheowana. Przy każdym następnym uruchomieniu aplikacja natychmiastowo uruchamiana jest z cache'a, podczas gdy w tle wysyłane jest zapytanie o plik z hashami wszystkich plików aplikacji (ngsw.json) i na tej podstawie sprawdzana jest potrzeba aktualizacji wersji aplikacji w cachu. Plik z hashami jest generowany na podstawie pliku ngsw-config.json, który z kolei jest generowany z CLI podczas budowania aplikacji.;Angular;;true
What is Push Notifications?;It allows asynchronous notifications and updates to be delivered to the user regardless of whether the web application is loaded or the browser is enabled. It is based on two browser standards - Push API and Notifications API. Push API allows us to push messages from the server to the browser, and the Notifications API to display them as they appear in the browser.;Pozwala na dostarczanie asynchronicznych notyfikacji i aktualizacji do użytkownika niezależnie czy aplikacja webowa jest załadowana lub czy przeglądarka jest włączona. Bazuje na dwóch standardach przeglądarki - Push API i Notifications API. Push API pozwala nam na pushowanie wiadomości z serwera do przeglądarki, a Notifications API na wyświetlaniu ich jak pojawią się w przeglądarce.;Angular;;true
What are the security concerns? (bezpieczeństwo);1. There is a Cross Site Scripting attack when the user enters some input, which might be an unwanted script, and we display it later on the website, the unwanted script can run and do bad things. Angular treats the values that are entered in the DOM as untrusted and will clean the unwanted elements. 2. Transport Protection security is also important. It's a way of secure requests between front-end and back-end. The way to do this is to use HTTPS everywhere. 3. Cross Origin Resources prevents us from making requests to pages other than from which the application came. We can do that by applying proper headers to the request. Angular's HttpClient service will take care of it for us.;1. Istnieje atak Cross Site Scripting, gdy użytkownik wprowadzi jakieś dane w inpucie, które mogą być niechcianym skryptem, a my wyświetlimy go później na stronie internetowej, niechciany skrypt może się uruchomić i zrobić złe rzeczy. Angular traktuje wartości wprowadzone w DOM jako niezaufane i usuwa niechciane elementy. 2. Ważna jest również ochrona transportu. Jest to sposób na bezpieczne requesty pomiędzy front-endem, a back-endem. Sposobem na to jest używanie wszędzie HTTPS. 3. Cross Origin Resources uniemożliwiają nam wysyłanie żądań do stron innych niż te, z których pochodzi aplikacja. Możemy to zrobić, stosując odpowiednie nagłówki do żądania. Usługa HttpClient Angulara zajmie się tym za nas.;Angular;;true
What are the advantages of monorepo? (monorepo adventages);1. Code sharing - with monorepo's help, we can easily create shared libraries and use them in many projects. This prevents code duplication. 2. Better organization - many teams from different projects can help each other to improve reusable code. 3. Simplified dependency management - the ability to manage dependencies for many projects, which will prevent the need to update each project separately if we decide to update a dependency.;1. Wspólny kod (code sharing) - z pomocą monorepo możemy w łatwy sposób tworzyć wspólne biblioteki i używać ich w wielu projektach. Pozwala to zapobiec duplikacji kodu. 2. Lepsza organizacja - wiele zespołów z różnych projektów może pomagać sobie żeby ulepszać reużywalny kod. 3. Ułatwione zarządanie zależnościami (simplified dependency management) - możliwość zarządzania zależnościami dla wielu projektów, co zapobiegnie potrzebie uaktualniania każdego projektu osobno jeżeli zdecydujemy się na aktualizację jakiejś zależności.;Angular;;true
How do module Injectors work? (ModuleInjectors);The first time a service request is made, the module's Injector creates that service, delivers it, caches it, and delivers the same instance wherever the service is requested. When a Component asks for a service, it first tries to locate it in the Injector connected to the component, if it does not find it, then it goes to the parents and searches the module's Injectors, trying to locate it.;Kiedy pierwszy raz jest prośba o serwis wtedy Injector modułu tworzy ten serwis, dostarcza go, cachuje go i dostarcza ten sam instance gdziekolwiek jest zapotrzebowanie na ten serwis. Kiedy Component zapyta o serwis najpierw stara się go zlokalizować w Injectorze połączonym z kompnentem, jeżeli go nie znajdzie wtedy dopiero idzie w do rodziców i przeszukuje Injectory modułu  starając się go zlokalizować.;Angular;;false
How can CSS be integrated into an HTML page? (import CSS, CSS import);There are three ways of integrating CSS into HTML: using <style> tags in the head section, using inline-styling, writing CSS in a separate file, and linking into the HTML page by the link tag.;Istnieją trzy sposoby integracji CSS z HTML: używanie tagów <style> w sekcji head, używanie stylów in-line, pisanie CSS w osobnym pliku i łączenie ze stroną HTML za pomocą znacznika link.;CSS;;false
What is the difference betweer Promise and Observable?;Promise handles a single event when an asynchronous operation returns successfully or with an error. Operation Promise cannot be canceled. Observable is like a Stream in many languages ​​and allows zero or more operations to be passed when we get data returned asynchronously. I honestly don't use Promise because I think Observable provides all the Promise features and much more besides.;Promise obsługuje pojedzyńcze zdarzenie kiedy asynchroniczna operacja wraca z sukcesem lub z błędem. Operacji Promise nie można anulować. Observable jest jak strumień (Stream) w wielu językach i pozwala na przekazanie zero lub większej ilości operacji kiedy dostajemy asynchronicznie zwrócone dane. Ja szczerze mówiąc nie używam Promise bo uważam, że Observable zapewnia wszystkie możliwości Promise i oprócz tego dużo więcej.;Angular;;true
What are the types of layouts? (HTML layout) (layout types);1. Normal flow - default arrangement of items by the browser. 2. Display property. 3. Flexbox. 4. Grid. 5. Floats 6. 'position' property 7. Table;1. Normal flow - default arrangement of items by the browser. 2. Display property. 3. Flexbox. 4. Grid. 5. Floats 6. 'position' property 7. Table;CSS;;true
What's the difference between normalization and resetting CSS?;When resetting CSS, we are talking about resetting the default browser settings. The browser has default CSS styles which are applied unless overwritten. Normalization, on the other hand, instead of resetting everything, keeps or sets in a specific way frequently used elements so that they look the same in all browsers.;Przy resecie CSS  mówimy o resetowaniu domyślnych ustawień przeglądarki. Przeglądarka ma domyślne style CSS, które są stosowane jeżeli ich nie nadpiszemy. Normalizacja natomiast zamiast resetować wszystko zachowuje, bądź ustawia w okreśłony sposób często używane elementy, żeby we wszystkich przeglądarkach wyglądały tak samo.;CSS;;false
What is TypeScript?;TypeScript is a strongly typed, object oriented programming language. TypeScriptis a superset of JavaScript. It means that TypeScript provides all the features and functionalities of JavaScript with additional features.;TypeScript to silnie typowany, obiektowy język programowania. TypeScript to superset JavaScript. Oznacza to, że zapewnia wszystkie cechy i funkcjonalności JavaScript z dodatkowymi cechami.;TypeScript;;true
What are the limitations of CSS?;1. CSS cannot always assure compatibility with every browser, you need to be cautious while choosing the style selector. 2. The parent selector tag is not available, thus you can’t select the parent selector tag. 3. Some selectors can lead to cross-browser issues due to their less browser-friendly behavior. 4. We cannot request a webpage through CSS.;1. CSS nie zawsze zapewnia kompatybilność z każdą przeglądarką, musisz być ostrożny przy wyborze selektora stylów. 2. Znacznik nadrzędnego selektora jest niedostępny, dlatego nie można wybrać nadrzędnego znacznika selektora. 3. Niektóre selektory mogą prowadzić do problemów z różnymi przeglądarkami ze względu na ich mniej przyjazne dla przeglądarek zachowanie. 4. Nie możemy zażądać strony internetowej za pośrednictwem CSS.;CSS;;false
What possibilities does SASS give us? (why sass);1. Variables - we can use variables many times to which we can assign colors, font sizes, etc. 2. Nested selectors - we can use selectors in selectors, so we write less code. 3. Operators - for mathematical operations in CSS. 4. Batches and imports - so we can write CSS code in different files and import them all into one file. 5. Mixins - for writing reusable CSS code fragments. 6. Functions - just like Mixins - we can write reusable CSS code, with the difference that functions return us a value that we can use. 7. Extends - enables inheritance between selectors. 8. Control directives - use conditions and loops to write complex code.;1. Zmienne - możemy wielokrotnie używać zmiennych, do którym możemy przypisać kolory, rozmiary czcionek, etc. 2. Nested selectors - możemy używać selektorów w selektorach, przez co piszemy mniej kodu. 3. Operatory - do matematycznych operacji w CSS. 4. Partiale i importy - dzięki czemu możemy pisać kod CSS w różnych plikach i importować je wszystkie w jeden plik. 5. Mixins - do pisania fragmentów kodu CSS wielokrotnego użytku. 6. Funkcje - podobnie jak Mixins - możemy pisać kod CSS wielokrotnego użytku, z tą różnicą, że funkcje zwracają nam wartość, której możemy użyć. 7. Extends - umożliwia dziedziczenie pomiędzy selectorami. 8. Control directives - do pisania skomplikowanego kodu używająć warunków i pętli.;CSS;;true
What is the difference between (change) and (ngModelChange)?;(change) is an event attached to a classic change event. We can use (change) even if we don't have a model in our input. (ngModelChange) is the @Output of the ngModel directive. It fires up when the model changes. This event cannot be used without the ngModel directive.;(change) jest eventem podpiętym do klasycznego change eventu. Możemy użyć (change) nawet jeżeli nie mamy modelu w swoim inputcie. (ngModelChange) jest @Output'em dyrektywy ngModel. Odpala się kiedy zmienia się model. Nie można użyć tego eventu bez dyrektywy ngModel.;Angular;;false
What are the advantages of FormGroup?;1. We can do corss-field validation. 2. We can check the status of more inputs at once. 3. Track changes of multiple inputs at once. 4. Match the form value on the data model (const x = {... this.model, ... this.form});1. Możemy przeprowadzać corss-field walidację. 2. Możemy sprawdzać stan większej ilości inputów na raz. 3. Śledzić zmiany wielu inputów na raz. 4. Matchować wartość formularza na data model (const x = { ...this.model, ...this.form });Angular;;false
What are Union types and what are Intersection types? (Union type, Intersection type);With Union type we define a parameter that can be one of many types. We use a vertical bar ('|') to enumerate the types that this parameter may have. The Intersection type combines many types into one. This allows us to create a single type that will have all the elements of the joined types.;Union typujemy parametr, który może być jednym z wielu typów. Używamy kreski pionowej (vertical bar - '|') do opisu typów, jakie może mieć ten parametr. Typ Intersection łączy wiele typów w jeden. To pozwala na stworzenie pojedyńczego typu, który będzie miał wszystkie elementy łączonych typów.;OOP;;true
When do we create Service?;1. The functionality needed is not required by the view. 2. We have to share logic in different components. 3. We have to divide the data in different components (NgRx helps here).;1. Potrzebna funkcjonalność nie jest wymagana przez widok. 2. Musimy dzielić logikę w różnych komponentach. 3. Musimy dzielić dane w różnych komponentach (tutaj pomaga NgRx).;Angular;;true
What access modifiers do you know in encapsulation?;private - only inside the same class, protected - only inside the same class or in derived classes, internal - only inside the same assembly, protected internal - combination protected OR internal (protected + internal), public - available everywhere;private - tylko wewnątrz tej samej klasy, protected - tylko wewnątrz tej samej klasy lub w klasach pochodnych, internal - tylko wewnątrz tego samego assembly, protected internal - kombinacja protected OR internal (protected + internal), public - dostępne wszędzie;OOP;;false
What is package-lock.json?;package-lock is a large list of each dependency listed in your package.json, the specific version that should be installed, the location of the module (URI), a hash that verifies the integrity of the module, the list of packages it requires, and a list of dependencies.;package-lock to duża lista każdej zależności wymienionej w naszym package.json, konkretna wersja, która powinna być zainstalowana, lokalizacja modułu (URI), hash, który weryfikuje integralność modułu, lista wymaganych pakietów i listę zależności.;TypeScript;;true
What types of Guard are there? (guard types);canActivate - checks whether it is possible to navigate to the page, canDeactivate - checks whether it is possible to leave the page, resolve - makes sure that the specified data is provided before redirecting to the page, canLoad - checks whether we can download the module at all, important information: with guarden canLoad does not work preloading.;canActivate - sprawdza czy umożliwić na nawigację do strony, canDeactivate - spradza czy umożliwić opuszczenie strony, resolve - pilnuje, żeby przed przekierowaniem na strone określone dane zostały zapewnione, canLoad - sprawdza czy w ogóle możemy dociągnąć moduł, ważna informacja: z guarden canLoad nie działa preloading.;Angular;;true
What is the <router-outlet> directive for?;<router-outlet> is used to display component templates defined in child routes.;<router-outlet> służy do wyświetlenia template'ów komponent'ów zdefiniowanych w child route'ach.;Angular;;false
Difference between CSS grid vs flexbox? (flexbox vs grid);1. CSS Grid Layout is a two-dimensional layout along with rows and columns. It is used for large-sized layouts. 2. Flexbox is a one-dimensional layout either within a row or a column. opisac ze parent jest in chanrge w gridzie;1. CSS Grid Layout to dwuwymiarowy układ wraz z wierszami i kolumnami. Jest używany do układów o dużych rozmiarach. 2. Flexbox to układ jednowymiarowy w wierszu lub kolumnie.;CSS;;true
How does 'position: relative' work? (position relative);The HTML element still has a reserved place in the document context, but we can move it (top, bottom, left, right) relative to its starting position in the context.;HTML Element dalej ma zarezerwowane miejsce w kontekście dokumentu, ale możemy przemieszczać go (top,bottom,left,right) względem jego miejsca początkowego miejsca w kontekście.;CSS;;false
What is Shadow DOM?;Shadow DOM is the standard for DOM encapsulation. It was made to enable encapsulation without relying on tools like <iframe> that weren't made for that. I think of it as a "DOM in the DOM" with its own tree structure and styles completely separate from the main DOM. Angular does not directly use the Shadow DOM, but emulates its operation, so it can be used even if the browser does not support the Shadow DOM. It is possible to enable the native Shadow DOM.;Shadow DOM jest to standard do enkapsulacji DOMu. Został stworzony, żeby umożliwić enkapsulacje, bez poleganiu na narzędziach jak <iframe>, które nie zostały stworzone do tego. Ja myślę o tym jako "DOM w DOM'ie" ze swoją własną strukturą drzewa i stylami zupełnie odseparowanymi od głównego DOM'u. Angular nie używa bezpośrednio Shadow DOM, ale emuluje jego działanie, więc może być używany nawet jeżeli przeglądarka nie obsługuje Shadow DOM. Istnieje możliwość włączenia właściwego Shadow DOM.;Angular;;true
What is SEO? (search engine optimization/pozycjonowanie);SEO is the process of optimizing a website to increase its visibility in search results. It consists of an On-Page and Off-Page process. 1. On-Page is the optimization of the website itself, its content and technical aspect (Html, Meta tags, etc). First, you need to identify phrases that are commonly entered into the search engine in order to find a page that is similar to our application. Once we find popular phrases, we include them in your page content. Optimize meta content - meta tags, headers, etc. Add photos, videos to increase credibility and engagement on the site, convincing search engines to show it to more people. 2. Off-Page is page optimization not related to the page itself, which as a frontend developer I did not delve into. It is associated with with setting up fanpages, marketing, etc.;SEO to proces optymalizacji strony internetowej w celu zwiększenia widoczności w wynikach wyszukiwania. Składa się on z procesu On-Page i Off-Page. 1. On-Page to optymizacja samej strony internetowej, jej zawartości i aspektu technicznego (Html, Meta tags, itd). Najpierw należy zidentyfikować popularnie wpisywane frazy w wyszukiwarkę w celu znalezienia strony o charakterze naszej aplikacji. Po znalezieniu popularnych fraz należy umieścić je w zawartości strony. Zoptymalizować meta content - meta tagi, headery, itd. Dodać zdjęcia, filmy, żeby zwiększyć wiarygodność i zaangażowanie na stronie, przekonując silniki wyszukiwarkowe do pokazania jej dla większej ilości osób. 2. Off-Page to optymizacja stronye nie związana z samą stroną, w którą jako frontend developer się nie zagłębiałem. Jest ona związana m.in. z zakładaniem fanpage'ów, marketingiem, itd.;HTML;;true
What is the difference between var, let, const?;Variables declared as var work in the scope of the entire function, and let until you close the scopa with "}". Const is just like let, but we use it when we are sure the variable will not be changed.;Zmienne zadeklarowane jako var działają w scopie całej funkcji, natomiast let do zamnięcia scopa znacznikiem "}". Const działa tak samo jak let ale używamy go kiedy jesteśmy pewni, że zmienna nie będzie zmieniana.;Angular;;true
What are Generic Types? (generics);Generic classes or functions allow you to delay the delivery of the type of data we operate on in these elements. In other words, generics allow you to write a class or function that can work with multiple types.;Generyczne klasy lub funkcje pozwalają na opóźnienie dostarczenia typu danych, na których operujemy w tych elementach. Innymi słowy, typy generyczne pozwalają na napisanie klasy lub funkcji, która może działać z wieloma typami.;OOP;;true
How does Calc work? (CSS calc);Calc can be used to specify the result of the mathematical operation of two or more values. For example to specify the element's width by the addition of two or more values.;Calc może służyć do określenia wyniku działania matematycznego dwóch lub więcej wartości. Na przykład, aby określić szerokość elementu przez dodanie dwóch lub więcej wartości.;CSS;;false
What are the properties of an Angular service? (service properties);1. Repeatedly used piece of functionality shared by components. 2. Responsible for a single, separate part of the functionality. 3. Possible for Dependency Injection.;1. Wielokrotnie używany fragment funkcjonalności dzielony przez komponenty. 2. Odpowiedzialny za pojedyńczą, oddzielną część funkcjonalności. 3. Możliwy do Dependency Injection.;Angular;;false
What is Dependency Injection? (DI);Dependency Injection is simply passing dependencies to other objects that were created outside of them. This is a very easy technique that eases testing because it allows dependencies to be mocked outside of the object being tested.;Dependency Injection to po prostu przekazywanie zależności do innych obiektów, które zostały utworzone poza nimi. To jest bardzo łatwa technika ułatwiające testy, ponieważ pozwala zależnościom być zmockowanym poza obiektem, który testujemy.;OOP;;true
What are the imperative vs declarative differences? (imperative vs declarative, imperatywny, deklaratywny);When we are programming Imperatively we are saying HOW we want to do something, whereas when we code declaratively we are saying WHAT we want to do or WHAT we want to get. If we are programming imperatively, we are telling our code how to work step by step: Get this data, then do this, then do that. In declarative programing we state - this is what we want, not how to get it. If we are programming declaratively, we are telling our code what we want. We set up pure functions (same inputs = same outputs) for our data sources to flow through which describe what we want. As our data sources change, our application will automatically react to these changes. In Angular RxJs allows for reactive programming which is a type od declarative programming. But as soon as we subscribe to something to pull data out of a stream, we are coding imperatively. It's important thing to keep in mind is that declarative code has some sort of underlying imperative implementation. Declarative code is just an abstraction on top of imperative code. It's higher level code that make code easier and less error prone but at some point beneath the surface imperative code is still required.;Kiedy programujemy imperatywnie, mówimy JAK chcemy coś zrobić, kiedy programujemy deklaratywnie, mówimy CO chcemy zrobić lub CO chcemy pozyskać. Jeśli programujemy imperatywnie, mówimy naszemu kodowi, jak ma działać krok po kroku: Pobierz te dane, a następnie zrób to, a następnie zrób tamto. Przy deklaratywnym programowaniu deklarujemy - to jest tym czego chce, nie mówimy w jaki sposób to pozyskać. Jeśli programujemy deklaratywnie, mówimy naszemu kodowi, czego chcemy. Definiujemy czyste funkcje (te same wejścia = te same wyjścia), przez które przepływają nasze źródła danych, które opisują to, czego chcemy. Gdy zmieniają się nasze źródła danych, nasza aplikacja automatycznie reaguje na te zmiany. W Angularze RxJs pozwalają na programowanie reaktywne, które jest rodzajem programowania deklaratywnego. Ale gdy tylko zasubskrybujemy do czegoś, aby wyciągnąć dane ze strumienia, kodujemy imperatywnie. Należy pamiętać, że kod deklaratywny ma jakąś imperatywną implementację. Kod deklaratywny jest po prostu abstrakcją nad kodem imperatywnym. Jest to kod wyższego poziomu, który sprawia, że ​​kod jest łatwiejszy i mniej podatny na błędy, ale w pewnym momencie pod powierzchnią nadal wymagany jest kod imperatywny.;Angular;;true
How is aggregation different from composition? (agregacja, kompozycja);We refer to both aggregation and composition when an object consists of other types, but we refer to composition when an object has a different component object that cannot exist without the main object. In aggregation, however, the main object contains another member object that may exist without the main object.;Zarówno o agregacji jak i w kompozycji mówimy, kiedy obiekt składa się z innych typów, jednak z kompozycją mamy doczynienia, kiedy obiekt posiada inny obiekt składowy, który nie może istnieć bez obiektu głownego. W agregacji natomiast obiekt główny zawiera inny obiekt składowy, który może istnieć bez obiektu głównego.;OOP;;false
What are pseudo elements and pseudo classes in CSS? (pseudoelements, pseudoclasses);In pseudo elements (::pseudo_element) you can control parts of an element, e.g. add to a::after {content: "(Link)"} and after each a a link will be added, or p::first-letter will change the style of the first letter. On the other hand, pseudo-classes (:pseudo_class_name) may react depending on the state of the element, e.g. a:hover imposes a style if we hover over it with the mouse.;W pseudo elementach (::nazwa_pseudo_elementu) można kontrolować części elementu, np. dodać do a::after{content:"(Link)"} i po każdym a zostanie dodany napis link, albo p::first-letter zmieni styl pierwszej literki. Natomiast pseudo klasy (:nazwa_pseudo_klasy) mogą reagować w zależności od stanu elementu, np. a:hover narzuca styl jeżeli najechaliśmy na niego myszką.;CSS;;true
What are Unit Tests?;Unit tests are tests written for "Unit" of code. Unit is a subjective definition and can stand for one or more functions, a line of code, or an object. Each unit test runs independently of the other unit tests.;Unit testy są testami pisanymi dla "Unita" kodu. Unit jest subiektywną definicją i może oznaczać jedną lub więcej funkcję, linię kodu lub obiekt. Każdy unit test uruchamia się niezależnie od pozostałych unit testów.;Testing;;true
What is TestBed?;Object for configuration and initialization of the environment for our unit tests. It provides functions for creating components and services in unit tests.;Obiekt do konfiguracji i inicjacji środowiska do unit testów, który udostępnia funkcje do tworzenia komponentów i serwisów w unit testach.;Testing;;true
Explain call(), apply() and, bind() methods.;[method1].call ([object1], [arguments_to_function_method1]) specifies the object on which we call the function [method1]. apply() is the same as call() only instead of arguments_to_functions_method1 being an array, apply() takes the arguments in an array. The bind() function instead of calling the function immediately, returns it to a variable.;[metoda1].call([obiekt1], [argumenty_do_funkcji_metoda1]) określa obiekt, na którym wywołujemy funkcję [metoda1]. apply() to to samo co call() tylko zamiast argumenty_do_funkcji_metoda1 po przecinku apply() pobiera argumenty w tablicy. Funkcja bind() zamiast od razu wywołać funkcję zwraca ją do zmiennej.;JavaScript;;false
What is monorepo?;Monorepo is a workspace where all development projects and libraries take place. Instead of keeping multiple repositories for a separate project, in monorepo we keep a single repository where projects and libraries can communicate with each other more easily.;Monorepo to workspace gdzie wszystkie developowane projekty i biblioteki mają miejsce. Zamiast utrzymywać wiele repozytorium dla oddzielnego projektu, w monorepo trzymamy pojedyńcze repozytorium, w którym projekty i biblioteki mogą w łatwiejszy sposób komunikować się między sobą.;Angular;;false
When do we create new Module?;1. If a Component uses a set of unique modules that are not used in the parent Component or the neighboring Component, then we have to create a separate module. Eg a page that contains header, body with form, and footer. Only the form needs ReactiveFormModule, so we create a new module for the component with the form. (rather a bit of an exaggeration from my point of view) 2. If a Component can be divided into subcomponents, we create a separate module for it. For example, if in HeaderComponent we want to make a separate Component for the menu icon and a separate one for the login button, then we create a separate module for it. (too exaggerating from my point of view);1. Jeżeli Component używa zestawu unikalnych modułów, które nie są użyte w parent Componencie alba sąsiednim Componencie, wtedy musimy stworzyć oddzielny moduł. Np. strona, która zawiera header, body z formularzem i footer. Tylko formularz potrzebuje ReactiveFormModule, więc na component z formularzem tworzymy nowy moduł. (raczej trochę przesada z mojego punktu widzenia) 2. Jeżeli Component może być podzielony w subcomponenty tworzymy oddzielny moduł na niego. Np. jeżeli w HeaderComponent chcemy zrobić oddzielny Component na ikonkę menu i oddzielną na przycisk logowania to tworzymy oddzielny moduł na niego. (też przesadza z mojego punktu widzenia);Angular;;true
What is the difference between one-way data binding and two-way data binding?;One way data bind sends data only one way - from view to component class or vice versa, and two way binding in two sides, eg "banana in a box" structure, ie classic brackets in square brackets used in Template forms.;One way data bind przesyła dane tylko w jedną stronę - od widoku do klasy komponentu lub odwrotnie, a two way binding w dwie strony, np. struktura "banana w pudełku" czyli nawiasy klasyczne w kwadratowych używane w formularzach typu Template.;Angular;;false
What are Effects?;Effets are responsible for all "side effects" that are performed when dispatching actions, including mainly interaction with services, and thus isolate these services from components, making them "pure components".;Effety odpowiadają za wszystkie "efekty uboczne", które wykonują się przy dispatchowaniu akcji, w tym głównie za interakcję z serwisami i tym samym izolują te serwisy od komponentów, przez co są "czystymi komponentami"(pure component).;Angular;;true
What are Cloning Techniques and what are they for? (copy object, clone object);JSON.parse(JSON.stringify([some_object])) - the problem with this approach is that if we have, for example, dates, it won't work, so you need to use a more Custom approach or Immutable.js. You can also use property extraction. The most common use is cloning, when we want to modify immutable objects, we copy them then with their state changed.;JSON.parse(JSON.stringify([jakis_obiekt])) - problem z tym podejściem jest taki, że jeżeli mamy np. daty to nie zadziała, dlatego trzeba używać bardziej Custom'owego podejścia albo  Immutable.js. Można też użyć property extraction. Najczęściej używa się klonowania, kiedy chcemy modyfikować immutable obiekty, kopiujemy je wtedy ze zmienionym stanem.;Angular;;true
What is CSS Specificity?;This is a value that determines which CSS settings take precedence in the event of a conflict. It is calculated on the basis of selectors, which have different values ​​depending on whether they select the element before the id, class / pre-class, element / pseudo-element.;Jest to wartość określająca, które ustawienia CSS mają priorytet w przypadku konfliktu. Wylicza się ją na podstawie selecktorów, które mają różną wartość w zależności od tego czy są zaznaczają element poprzed id, klasę/preudoklasę, element/pseudoelement.;CSS;;true
What are the characteristics of Event Binding? (Event Binding properties);- Event Binding is the easiest way to listen for events in the Component view. - It is impossible to listen to the event that emits outside the Component view, except for window, document, body (eg (document: click) = "functionA()"). Listening to global events in this way is not recommended, especially in reusable Components. - Compnent-parent can listen and catch a DOM event (not an Angular event) fired inside a child-component, because there is an Event Bubbling for regular events. - Event Binding will be active on the element from the very beginning and will be active until the element is removed from the DOM, so we cannot control when to add or remove a listener for a given event dynamically.;- Event Binding jest najprostszym sposobem na nasłuchiwanie eventów w widoku Componentu. - Nie można nasłuchiwać eventu, który emituje poza widokiem Componentu, za wyjątkiem window, document, body (np. (document:click)="funkcjaA()"). Nasłuchiwanie globalnych eventów w ten sposób nie jest zalecane, szczególnie w reużywalnych Componentach. - Compnent-rodzic może nasłuchiwać i złapać DOM event (nie event Angularowy) uruchamiany wewnątrz child-componentu, ponieważ w przypadku zwykłych eventów jest Event Bubbling. - Event Binding będzie aktywny na elemencie od samego początku i będzie aktywny aż element nie zostanie usunięty z DOMu, więc nie możemy kontrolować kiedy dodać lub usunąć nasłuchiwanie danego eventu dynamicznie.;Angular;;false
What are Zones?;The "zone" is a common place for storing the execution context informations about asynchronous operations that are run in it.;"Zone" jest wspólnym miejscem przechowywania informacji (execution context) o asychronicznych taskach, które są w nim uruchomione.;Angular;;true
What are the elements of the CSS Box Model?;The elements are content (like text and images), padding (the area around content), border (the area around padding), and margin (the area around the border);Elementy to content (np. tekst i obrazy), padding (obszar wokół treści), bordery (obszar wokół paddinga), i marginesy (obszar wokół obramowania);CSS;;true
How can we lazy load Component?;We can do this with const {GreetComponent} = await import ('./ greet.component') and create it dynamically using ComponentFactoryResolver.resolveComponentFactory (GreetComponent);Tak, możemy to zrobić za pomocą const { GreetComponent } = await import('./greet.component') i stworzyć go dynamicznie używając serwisu ComponentFactoryResolver.resolveComponentFactory(GreetComponent);Angular;;true
What are the key HTML5 page structure elements?;<header> header or top of the page, <footer> fotter or bottom of the page, <section> one section that is thematically similar to other sections, <article> standalone content, <nav> navigation functionality;<header> nagłówek lub góra strony, <footer> fotter lub dół strony, <section> sekcja, która jest tematycznie podobna do innych sekcji, <article> samodzielna treść, <nav> funkcja nawigacji;CSS;;false
What is Observable?;Observable is a stream of data that we expect in some further point in time. The Observable type itself helps us with handling of asynchronous operations.;Observable to są strumienie danych, których spodziewamy się po jakimś czasie. Sam Observable typ, który pomaga nam w obsłudze zdarzeń asynchronicznych.;Angular;;true
What is Continuous Delivery?;Continuous Delivery is a practice in which teams produce software in short cycles, as well as the process of transferring this software to the production environment. Usually, after completing the development of a given functionality, the code is built and transferred to test environments, which then are tested on these environments using as much automation as possible. Later, a decision is made to transfer the functionality to the production environment.;Continuous Delivery to praktyka, w której zespoły wytwarzają oprogramowanie w krótkich cyklach, jak i sam proces przenoszenia tego oprogramowania na środowisko produkcyjne. Zazwyczaj jest tak, że po zakończeniu developmentu danej funkcjonalności buduje się kod i przenosi się na środowiska testowe, które następnie używając jak największej automatyzacji jest testowane na tych środowiskach. Później podejmowana jest decyzja o przeniesieniu funkcjonalności na środowisko testowe.;Angular;;true
What is REST?;REST is an API design concept which consists of certain requirements, ie 1. Client-Server - client and server are separated. The client should not be interested in how the data is generated on the server and likewise the server should not know e.g. how the data is presented to the user. 2. Stateless - each query must provide all the information needed for the server to understand, rather than rely on the values ​​provided in previous requests. Holding a session on the server violates this rule, so the session must be held entirely by the client. 3. Layered-system - it's about the division of responsibilities, each layer should have a specific purpose. For example, we cannot return the <div> HELLO </div> message from the server because we are mixing the layer that generates the data with the presentation layer. 4. Resource identification - the request must define what resources it wants to obtain (via URL). 5. Manipulating resources through their representation - The client has a resource representation (eg URL + metadata) and on this basis he can manipulate data on the server side, using eg POST, PATCH, PUT, DELETE. 6. Self-described message - each request must contain information on how to process it, eg whether it is in the form of json or xml, the header must have this information. 7. Cacheable - an explicit or implicit response must state whether the data is cacheable or noncountable. Good cache management can make a lot of unnecessary client-server interaction.;REST jest to koncepcja projektowania API, która składa się z pewnych wymogów, tj. 1. Client-Server - klinet i serwer są odseparowani. Klient nie powinein być zainteresowany jak dane są generowane na serwerze i analogicznie serwer nie powinien wiedzieć np. jak przedstawia się dane dla użytkownika. 2. Bezstanowość - każde zapytanie musi powiadać wszystkie informacje potrzebne do zrozumienia przez serwer, niż polegać na wartościach przekazanych we wcześniejszych requestach. Przetrzymywanie sesji na serwerze narusza tą zasadę, więc sesja musi być trzymana w całości przez klienta. 3. Layered-system (system warstwowy) - chodzi o podział obowiązków, każda warstwa powinna mieć określony cel. Np. nie możemy zwrócić z serwera wiadomośći <div>HELLO</div>, ponieważ mieszamy warstwe, która generuje dane z warstwą prezentacji. 4. Identyfikacja zasobów - request musi określić jakie zasoby chce pozysąc (przez URL). 5. Manipulacja zasobami przez ich reprezentację - Klient ma reprezentację zasobu (np. URL+metadane) i na jej podstawie może manipulować danymi po stronie serwera, używając np. POST, PATCH, PUT, DELETE. 6. Samoopisana wiadomość - każdy request musi zawierac informację jak go przeprocesować, np. czy jest w postaci jsona lub xml, header musi mieć tą informację. 7. Cacheable - odpowiedź w sposób jawny lub niejawny musi określić czy dane są cachowalne czy niecachowalne. Dobre zarządzanie cachem może sporo niepotrzebnej interacji klient-serwer.;OOP;;true
What is the communication method Redux -> Angular?;We dispatch the actions that are analyzed by the Reducer, which appropriately replaces the Store state depending on the action.;Dispatchujemy akcje, które są analizowane przez Reducer, który odpowiednio podmienia stan Store'a w zależności od akcji.;Angular;;false
How trackBy works?;In trackBy, we provide a function that will be used to identify the object from the * ngFor array. If we display the array in the * ngFor loop, and then assign a completely new array to the variable with already existing records from the previous array, then without the trackBy function, the entire array will be re-rendered in the view. If we give the appropriate function in trackBy, thanks to it Angular will check if a given row already exists in the previous table and if the record has not changed, it will not render it again.;W trackBy podajemy funkję, która będzie używana do zidentyfikowania obiektu z tablicy *ngFor. Jeżeli wyświetlamy tablicę w pętli *ngFor, po czym pod zmienną przypiszemy kompletnie nową tablicę zawierającą już istniejące rekordy z wcześniejszej tablicy to bez funkcji trackBy cała tablica zostanie na nowo zrenderowana na widoku. Jeżeli podamy odpowiednią funkcję w trackBy, dzięki niej Angular będzie sprawdzał czy dany wiersz już istnieje we wcześniejszej tablicy i jeżeli rekord się nie zmienił nie będzie go ponownie renderował.;Angular;;true
What are the advantages of ChangeDetection.OnPush?;1. Performance - Components are not checked if OnPush conditions are not met. 2. It prevents updating the state of presentation components in a different way than they should update - by receiving data from a container-component or by broadcasting an event.;1. Wydajność - komponenty nie są sprawdzane jeżeli warunki OnPush nie są spełnione. 2. Zapobiega uaktualniania stanu komponentów prezentacyjnych w inny sposób niż powinny się uaktualniać - poprzez otrzymanie danych z komponentyu-kontenera lub wyemitowaniu eventu.;Angular;;false
What runs first Promise or setTimeout?;Promise.resolve schedules a microTask and the setTimeout schedules a macrotask. MicroTasks are executed before macroTasks in Callback Queue.;Promize.resolve wywołuje microTask, a setTimeout wywołuje macroTask. MicroTaski wytwoływane są przed MacroTaskami w Callback Queue.;JavaScript;;true
What are the types of Injectors?;1. ModuleInjector - Defined in the module using @NgModule (providers: []) or @Injectable (providedIn: {module_name}) 2. ElementInjector - Defined in the providers' proposition in the @Compnent() or @Directive() decorator.;1. ModuleInjector - definiowany w module za pomocą @NgModule(providers:[]) lub @Injectable(providedIn:{nazwa_modułu}) 2. ElementInjector - definiowane w propecji providers w dekoratorze @Compnent() lub @Directive().;Angular;;false
What is Application Shell?;Application shell is a way to render parts of an application using 'route at build time' (?). It can improve the user experience by quickly launching a statically rendered page while the browser downloads full client version and switches to it automatically after the code is downloaded. This gives the user a meaningful first paint of your application that appears quickly because the browser renders HTML and CSS without needing to initialize any JavaScript.;Application shell jest sposobem na renderowanie części aplikacji używając 'route at build time'(?). Może polepszyć user experience poprzez szybkie uruchamianie statycznie renderowanej strony podczas kiedy przeglądarka ściąga full client version i przełącza się na niego automatycznie po tym jak kod się ściągnie. To daje użytkownikowi meaningful first paint Twojej aplikacji, która pojawia się szybko ponieważ przeglądarka renderuje HTML i CSS bez potrzeby to initialize any JavaScript.;Angular;;false
What is CSS?;CSS, or Cascading Style Sheet, is a style sheet language used with HTML to format and display the elements specified in HTML document. While HTML defines the structure of a page, CSS specifies the document’s style, including page layout, colors, fonts, etc.;CSS, czyli Cascading Style Sheet, to język arkuszy stylów używany z HTML do formatowania i wyświetlania elementów określonych w dokumencie HTML. Podczas gdy HTML definiuje strukturę strony, CSS określa styl dokumentu, w tym układ strony, kolory, czcionki, itd.;CSS;;true
What is tree-shaking?;This defines a process during application building in which unused code is not included in the package being built, thus making the package smaller.;W ten sposób określa się proces podczas budowy aplikacji, w którym nieużywany kod nie jest dołączany do budowanej paczki, przez co ma ona mniejszy rozmiar.;Angular;;true
Why Unit Tests? (why tests);To test the functionality of our code, e.g. whether our code works as a pointer or not. I also liked writing them so that no one would break my code. If the code that I originally wrote suddenly stops working because someone has changed something, it will be picked up by unit tests.;Żeby przetestować funkcjonalność naszego kodu, np. czy nasz kod działa jak poinien czy nie. Ja lubiłem też pisać je żeby nikt nie psuł mojego kodu. Jeżeli kod, którego początkowo byłem autorem nagle przestanie działać, bo ktoś coś w nim zmienił, zostanie to wychwycone przez unit testy.;Testing;;true
Why is composition over inheritance preferable?;The rule of thumb is to prefer composition to inheritance, but don't always use it, although I've heard of developers who always consider composition because they think it's always better to replace inheritance with composition. I disagree, I think that when an object needs the entire interface of another object, if we design it around what it is, then we tend to inherit, if the object only wants some part of another object, or when we design it around that what it does then the composition is recommended. Often a composition is recommended over inheritance because it is easier to modulate later, with composition easier to change behavior by Dependency Injection or Setter, inheritance is more rigid. Example - RobotA inherits from Robot and has a driving method because all robots are driving. Shepherd inherits from Pies because all dogs are barking. If we want to create a SuperRobot that drives and barks, so as not to make a very complicated inheritance structure, our SuperRobot class adopts the Dog dog object and the Robot robot object through the composition and its methods are defined around these objects - Rides () {robot. Rides () } and Bark () {dog.Bitch ()};Zasada jest taka, aby preferować kompozycję od dziedziczenia, ale nie używać jej zawsze, choć słyszałem o developerach, którzy uważają kompozycji zawsze bo uważają, że zawsze lepiej zastąpić dziedziczenie kompozycją. Ja się z tym nie zgadzam, uważam, że w przypadku kiedy obiekt potrzebuje całego interfejsu innego obiektu, jeżeli projektujemy go wokół tego czym jest, wtedy chylimy się w stronę dziedziczenia, jeżli natomiast obiekt chce tylko jakąś część innego obiektu lub kiedy projektujemy go wokół tego co robi wtedy zalecana jest kompozycja. Często kompozycja zalecana jest nad dziedziczeniem ponieważ jest łatwiejsza do modycikacji później, z kompozycją łatwiej zmienić zachowanie przez Dependency Injection albo Settery, dziedziczenie jest bardziej sztywne. Przykład - RobotA dziedziczy po Robot i ma metodę jeździ bo wszystkie roboty jeżdzą. Owczarek dziedziczy po Pies bo wszystkie psy szczekają. Jeżeli chcemy stworzyć SuperRobota, który i jeździ i szczeka to żeby nie robić bardzo skomplikowanej struktury dziedziczenia to nasza klasa SuperRobot przyjmuje przez kompozycję obiekt Pies pies i obiekt Robot robot i jej metody zdefiniowane są wokół tych obiektów - Jeździ(){robot.Jeździ()} i Szczeka(){pies.Szczeka()};OOP;;true
What is the difference between Observable and Subject? (observable vs subject, subject vs observable);First of all, Observable is unicast, ie each subscriber gets copies of the observables, Subject is multicast, ie many subscribers share the same stream. Subject can also be an observer.;Przede wszystkim Observable jest unicast, tzn. każdy subskrybent dostaje kopie observabli, Subject jest multicast, tzn. wielu subskrybentów dzieli ten sam stream. Subject może być również observerem.;Angular;;true
What is a box model?;Each HTML element is interpreted by CSS as a rectangle (box). Each box has content, padding, border and margin, the values ​​of which we can specify.;Każdy element HTML jest interpretowany przez CSS jako prostokąt (pudełko). Każde pudełko ma content, padding, border i margin, którego wartości możemy określać.;CSS;;false
What is mergeMap and how does it work?;mergeMap is a Higher-order mapping operator. It is used to support nested Observables. Each newly issued source Observable parallelly refers to the internal Observable without waiting for its predecessor, so it can run a bit faster, but we don't get the data in any particular order on the output.;mergeMap jest operatorem typu Higher-order mapping. Służy do obsługi zagnieżdżonych Observabli. Każdy nowo wyemitowany źródłowy Observable rónolegle odwołuje się do wewnętrznego Observabla nie czekając na poprzednika, przez co może działać odrobinę szybciej, ale na wyjściu nie otrzymujemy danych w konkretnej kolejności.;Angular;;false
What are local redirects and what are absolute ones?;Lokalne redirecty zmieniają pojedyńczy segment URL, natomiast absolutne zmieniają cały URL.;Lokalne redirecty zmieniają pojedyńczy segment URL, natomiast absolutne zmieniają cały URL.;Angular;;false
What is Notifications API?;API that allows websites to control the display of system notifications to the user.;API, które pozwala stronom internetowym kontrolować wyświetlanie systemowych notyfikacji dla użytkownika.;Angular;;false
What is z-index?;z-index is used to specify the order of elements that overlap each other. Its default value is zero and can take both negative and positive values. A higher z-index value is stacked above the lower index element.;z-index służy do określenia kolejności nakładających się elementów. Jego wartość domyślna to zero i może przyjmować zarówno wartości ujemne, jak i dodatnie. Wyższa wartość z-index'u jest umieszczana nad niższą wartością.;CSS;;true
Why do we need compileComponents?;napisać;napisać;Testing;;true
What is RxJS?;RxJS is a library for creating asynchronous programs using observabli.;RxJS to biblioteka do tworzenia asynchronicznych programów przy użyciu observabli.;Angular;;true
What code do you put in a component and which in a service?;I limit code in a component to only what the view requires. We place all the remaining code on the website.;Kod w komponencie należy ograniczyć tylko do tego, wymaganego przez widok. Cały pozostały kod umieszczamy w serwisie.;Angular;;false
What are the properties of Interpolation?;-can not change the state of the application, cannot change any data, -must be quick and simple, without any business logic, -idempotent - i.e. how many times we call the same, the obtained value will be the same.;-nie może zmieniać stanu aplikacji, nie może zmieniać żadnych danych, -musi być szybkie i proste, bez żadnej logiki biznesowej, -idempotentny - tzn, że jak wiele razy wywołamy to samo to otrzymana wartość będzie taka sama.;Angular;;true
What are @HostListener's properties?;- @HostListener is an Angular decorator that is used to listen for DOM events on a Component's host element or Directive's host element (e.g. <div onlyMyBeacon>). - @HostListener() starts listening as the directive is initialized and stops listening automatically as the directive is removed. - @HostListener catches and listens for events from childrens or nested items when the event is bubbled to the item host.;- @HostListener jest decoratorem Angulara, który jest używany do nasłuchiwania eventów DOMu na host elemencie dyrektywy Componentu albo zdefiniowanego atrybutu (np. <div onlyMyBeacon>). - @HostListener() zaczyna nasłuchiwanie jak dyrektywa jest zainicjalizowana i przestaje nasłuchiwać automatycznie jak dyrektywa jest usunięta. - @HostListener łapie i nasłuchuje do eventów z childrenów albo nested elementów kiedy event jest bubblowany do host elementu.;Angular;;false
What are the advantages of TypeScript? (TypeScript benefits, TypeScript advantages));1. Cross-platform - can be installed on any operating system. 2. Object-oriented - has classy, ​​interface, and modules. 3. Strict Type-Checking while writing an application helps to detect errors before the application is launched.;1. Cross-platform - może być zainstalowany na każdym systemie operacyjnym. 2. Object-oriented - ma classy, interface, i moduły. 3. Strict Type-Checking podczas pisania aplikacji pomaga w wykrywaniu błędów zanim zostanie uruchomiona aplikacja.;TypeScript;;true
What is Serialization? (Serializacja);It is the process of transforming objects (such as instances of certain classes) into a stream of bytes, maintaining the state of the object. The reverse process is the deserialization process. We use those processes in: 1. In memory we keep serialized data. 2. Http uses serialization when transmitting data through a web browser. 3. Video streaming - in an applitcation that involves video streaming, the video is broken down in packets, which are a collection of bytes transmitted serially to the client. In TypeScript you can call the JavaScript function JSON.stringify to serialize an object to a JSON string and JSON.parse deserializes the JSON string to an object.;To proces przekształcania obiektów (takich jak np instancji określonych klas) w strumień bajtów, z zachowaniem stanu obiektu. Procesem odwrotnym jest deserializacja. Używamy tych procesów w: 1. W pamięci trzymamy serializowane dane. 2. Http używa serializacji do przesyłania danych przez przeglądarkę. 3. Streamowanie video - w aplikacji zawierającej streaming video, to video jest podzielone na pakiety, które są kolekcją bajtów przesyłanych seryjnie do klienta. W TypeScriptcie możemy użyc funkcji JavaScriptowej JSON.stringify do serializacji obiejtów do stringa i JSON.parse do deserializacji stringa do obiektu.;TypeScript;;true
Why forRoot and forChild?;If we want our module to provide a service that will be provided only once in the application, then we define various possibilities of importing such a module. forRoot and forChild will import the module with all necessary things, but forRoot will additionally provide this service. Use forRoot / forChild convention only for shared modules with providers that are going to be imported into both eager and lazy module modules. https://indepth.dev/posts/1056/avoiding-common-confusions-with-modules-in-angular;Jeżeli chcemy, żeby nasz moduł providował serwis, który będzie tylko raz providowany w aplikacji, wtedy definiujemy różne możliwości importu takiego modułu. forRoot i forChild będzie importował moduł ze wszystkimi niezbędnymi rzeczami, ale forRoot będzie dodatkowo jeszcze providował ten serwis. Use forRoot/forChild convention only for shared modules with providers that are going to be imported into both eager and lazy module modules. https://indepth.dev/posts/1056/avoiding-common-confusions-with-modules-in-angular;Angular;;false
What are pipes? (What is pipe);Pipes are functions that transform data before displaying it. If we have a data type that must be displayed in a certain way in many places in our application, we declare a pipe for it, which modifies it in the view before displaying it.;Pipes są to funkcje, które służą do transormacji danych przed ich wyświetleniem. Jeżeli mamy typ danych, który w wielu miejscach naszej aplikacji musi być wyświetlany w określony sposób to deklarujemy dla niego pipe, który na widoku modyfikuje go przed wyświetleniem.;Angular;;true
What are CSS Image Sprites? (CSS Sprites);An image sprite is a collection of images put into a single image. A web page with many images can take a long time to load and generates multiple server requests. Using image sprites will reduce the number of server requests and save bandwidth.;CSS Sprites to technika pozwalająca na łączenie wielu mniejszych obrazów, wykorzystywanych na stronie www, w jeden większy plik, dzięki czemu zmniejszymy czas ładowania strony oraz zapobiegniemy nieprzyjemnym efektom "doładowywania" się brakujących grafik.;CSS;;true
What are the different types of CSS Selectors?;Universal Selector, Element type Selector, ID selector, Class selector, Descendant combinatory, Child Combinator, General Sibling Combinator, Adjacent sibling combinator, and Attribute selector.;Selektor uniwersalny, selektor typu elementu, selektor identyfikatora, selektor klasy, kombinator potomków, kombinator podrzędny, kombinator ogólnego rodzeństwa, kombinator sąsiadującego rodzeństwa i selektor atrybutów.;CSS;;true
What is Interpolation?;Interpolation is one-way binding from Component class to it's template.;To jednokierunkowe bindowanie z klasy komponentu do template'a.;Angular;;true
Tell us about the general CSS nomenclature.;In CSS, the styling is written in value and property fashion. The entire style is wrapped in curly braces and attached to the selector. This creates a style sheet that can be applied to an HTML page.;W CSS stylizacja jest napisana w oparciu o propercje i ich wartości. Całość owinięta jest w nawiasy klamrowe i przypisana do selektora. Tworzy to arkusz stylów, który można zastosować do strony HTML.;CSS;;false
What are the dependency resolution modifiers in Dependency Injection?;@Optional() - when dependencies are not found, null is returned instead of throwing an exception, @SkipSelf() - dependency searches start from the parent, @Self() - dependency searches are performed only in the current element, @Host() - dependency searches will only take place in the element's Injector or in the element's parent Injector. Angular names the parent element as 'host'.;@Optional() - kiedy zależności nie zostanie znaleziona zwracany jest null zamiast rzucanego wyjątku, @SkipSelf() - poszukiwania zależności zaczynają się od rodzica, @Self() -  poszukiwania zależności odbywają się tylko w aktualnym elemencie, @Host() - poszukiwania zależności odbędą się tylko w Injectorze elementu lub w Injectoerze parent elementu. Angular nazywa parent element jako 'host'.;Angular;;false
What are the ways to load modules?;-Eager Loading, -Lazy Loading, -Preloading (Eager Lazy Loading, doesn't work with canLoad route guard).;-Eager Loading, -Lazy Loading, -Preloading (Eager Lazy Loading, nie działa z Guardem canLoad).;Angular;;false
When do we create separate Component? (new component/nowy component);If the element has: 1. Own logic of interaction with the user. 2. Complicated layout or animations. 3. Any method that may make it difficult to understand parent Compnent's logic. 4. It differs visually.;Jeżeli element posiada: 1. Własną logikę interakcji z użytkownikiem. 2. Skomplikowany layout lub animacje. 3. Jakąkolwiek metodę, która może utrudnić zrozumienie logiki parent Compnentu. 4. Różni się wizualnie.;Angular;;true
What is the difference between fakeAsync and waitForAsync?;Both are test tools that are aimed at assisting in testing asynchronous functionality. In fakeAsync we can control the passage of time using tick() and clear macroTask and microTasks queues using flush() and flushMicrotasks(). waitForAsync supports actual http requests, fakeAsync doesn't. I prefer using fakeAsync to test asynchronous code. fakeAsync allows us to write tests that are easier to read without the need of using nested code. waitForAsync will handle promises fine, but not very well for example with setTimeout() or debounce. fakeAsync, on the other hand, does just that. You can use it with both promise, setTimeout, and practicly any type of asynchronous code where waitForAsync is only able to work with promises.;fakeAsync i waitForAsync służą to pomocy w testowaniu asynchronicznej funkcjonalności. W fakeAsync możemy kontrolować upływ czasu używając funkcji tick() i czyścić kolejkę macroTasków i microTasków używając funkcji flush() i flushMicrotasks(). waitForAsync umożliwia robienie http requestów, w fakeAsync nie jest to możliwe. Preferuję używanie fakeAsync do testowania asynchronicznego kodu. fakeAsync umożliwia nam pisanie testów, które są czytelniejsze bez potrzeby użycia zagnieżdżonego kodu. waitForAsync poradzi sobie z promisami w porządku ale nie poradzi sobie dobrze np. z setTimeout() lub debounce. fakeAsync natomiast dobrze sobie z tym radzi. Można go używać zarówno z promise, setTimeout i praktycznie z każdym typem asynchronicznego kodu, kiedy waitForAsync jest w stanie pracować tylko z promisami.;Testing;;true
What is Type Assertion in TypeScript?;Type assertion is used to determine the type of a value.;Type assertion działa jak rzutowanie (casting) i jest używane żeby określić typ dla wartości.;TypeScript;;true
What is True mock?;These are more complicated objects that verify whether they were used exactly in a specific way, e.g. they can check whether only a specific method was called, whether it was run only once and whether it had specific parameters. They are hard to work with and usually an excess of what the unit test needs.;Są to bardziej skomplikowane obiekty, które weryfikują czy zostały użyte dokładnie w konkretny sposób, np. mogą sprawdzić czy tylko konkretna metoda została wywołana, czy została uruchomiona tylko raz i czy miała konkretne parametry. Są ciężkie do pracy i zazwyczaj są nadmiarem tego czego unit test potrzebuje.;Testing;;false
Explain cookies vs localStorage. (localStorage vs cookies);Using localStorage, web applications can store data locally in the browser. Before HTML5, application data was automatically sent in cookies with each request to the server. localStorage is more modern, however there are different pros and cons to both technologies. Cookies: - entered before HTML5, - have an expiration date, - cleared after the expiration date, - are sent with each request to the server, - have a 4KB limit, - can only hold strings, localStorage: - introduced with HTML5, - no expiration date , -cleared by JavaScript, -select what date is to be sent to the server, -limit up to 5MB.;Za pomocą localStorage, aplikacje webowe mogą przetrzymywać dane lokalnie w przeglądarce. Przed HTML5 dane aplikacji były automatycznie wysyłane w cookies z każdym requestem do serwera. localStorage jest bardziej nowoczesny, jednak są różne zalety i wady (pros and cons) do obu technologii. Cookies: -wprowadzone przed HTML5, -mają datę wygaśnięcia, -czyszczone po dacie wygaśnięcia, -są wysyłane z każdym requestem do serwera, -mają limit 4KB, -mogą przetrzymywać tylko stringi, localStorage: -wprowadzone z HTML5, -nie ma daty wygaśnięcia, -czyszczone przez JavaScript, -należy wybrać jaka data ma być wysłana do serwera, -limit do 5MB.;JavaScript;;false
How does the unknown type work? (typ unknown, unknown typ);It is similar to the any type. You can assign all types to it, but you cannot assign the uknown value to variables with a type other than unknown or any without casting (casting).;Działa podobnie do typu any. Można przypisać do niego wszystkie typy, jednak nie można przypisać wartości uknown do zmiennych z innym typem niż unknown lub any bez rzutowania (casting).;TypeScript;;true
What are CSS custom properties or CSS variables?;Custom properties are entities that contain values to be reused throughout a document so we often refer to them as CSS variables. --some-color: #990000 .card {color: var(--some-color) };Custom properties zawierają wartości, umożliwiające reużywanie ich w dokumencie, więc często odnosimy się do nich jako zmienne CSS. --some-color: #990000 .card {color: var(--some-color) };CSS;;true
What are Higher-order mappings operators?;The xxxMap() family of operators. Each of these operators maps each value from the source Observable to the nested one, automatically subscribing to it, broadcasting the results, and unsubscribing when the upload is complete.;Rodzina operatorów xxxMap(). Każdy z tych operatorów mapuje każdą wartość ze źródłowego Observable to zagnieżdzonego, automatycznie subskrybująć do niego, emitując wyniki i odsubskrybując po zakończeniu przesyłu.;Angular;;false
Describe inline/block/block-inline.;1. Inline elements: respect left & right margins and padding, but not top & bottom, cannot have a width and height set, allow other elements to sit to their left and right. 2. Block elements: respect all of those, force a line break after the block element, acquires full-width if width not defined. 3. Inline-block elements: allow other elements to sit to their left and right, respect top & bottom margins and padding, respect height and width.;1. Elementy inline: uwzględnia left i right marginesy i padding, ale nie top i bottom,  nie może mieć ustawionego width i height, elementy inline ustawiane są obok siebie. 2. Elementy block: uwzględniają wszystkie te wartości, wymuszają znak nowej linii po elemencie block, rezerwują całą długość jeżeli propercja width nie jest ustawiona. 3. Elementy inline-block: ustawione są obok siebie, uwzględniają top, bottom, marginesy, padding, height, i width.;CSS;;true
What is the difference between an abstract class and an interface?;1. In an abstract class, both the declarations and definitions can be implemented, while in the interface there are only declarations. 2. You can inherit from only one abstract class, you can use on many interfaces. 3. We cannot define fields in the interface. 4. In the interface we cannot use any access modifiers because everything declared in it is public. 5. Declarations in the interface cannot be defined as static, virtual, abstract or sealed.;1. W klasie abstrakcyjnej zarówno same deklaracje jak i definicje mogą być zaimplementowane, natomiast w interfacie występują same deklaracje. 2. Można dziedziczyć tylko po jednej klasie abstrakcyjnej, można korzystać po wielu interfacach. 3. W interfacie nie możemy definiować fieldów. 4. W interfacie nie możemy używać żadnych modyfikatorów dostępu ponieważ wszystko w nim zadeklarowane jest publiczne. 5. Deklaracje w interfacie nie mogą być zdefiniowane jako static, virtual, abstract lub sealed. 6. W odróżnieniu od Interfejsu klasa abstrakcyjna nie jest kontraktem, który tylko mówi nam w jaki sposób metoda powinna się zachowywać. Klasa abstrakcyjna mówi nam również jak klasa ma się zachowywać, więc modyfikatory dostępu typu public, private mogą być w niej używane.;OOP;;false
Explain value type vs reference type.;A value type cannot be large in size because it is kept on a stack that has a predetermined size. The value type cannot change, a new object is created each time you try to change it. The reference pointer itself is held on the stack, but the object it points to is too large to hold on the stack, so it is put on the stack. For this reason, access to an object of a reference type is slower than that of a value type. We can modify an object of a reference type and assign it to different references without the need to copy.;Typ wartościowy nie może mieć dużego rozmiaru, ponieważ jest trzymany na stosie, który ma z góry określony rozmiar.  Typ wartościowy nie może ulec zmianie, przy każdej próbie zmiany tworzony jest nowy obiekt. Sam wskaźnik referencji jest trzymany na stosie, jednak obiekt na który wskazuje jest zbyt duży, żeby trzymać go na stosie, więc jest on umieszczany na stercie.  Z tego też powodu dostęp do obiektu typu referencyjnego jest wolniejszy niż typu wartościowego. Obiekt typu referencyjnego możemy modyfikować i przypisywać do różnych referencji bez potrzeby kopiowania.;OOP;;false
Difference between <header> and <h1>.;<header> is used to design the header as a whole with different element including logos or navigation bar. <h1> is the textual part only.;<header> służy do nagłówka jako całości z różnymi elementami, w tym logo lub paskiem nawigacyjnym. <h1> to tylko część tekstowa.;HTML;;true
What is Dummy?;Dummy is just an object that fills the place, a "clog". They don't do anything interesting, they are only used in place of real objects, i.e. a function that takes an object as a parameter but doesn't care what the object will be.;Dummy jest po prostu obiektem, który wypełnia miejsce, taka "zapchajdziura". Nie robią nic interesującego, są używane tylko w miejsce prawdziwych obiektów, tj. funkcja która jako parametr przyjmuje obiekt, ale nie obchodzi ją jaki będzie ten obiekt.;Testing;;false
What are the ways of up-down communication of components?;1. From parent to child through propercje with the Input () decorator. 2. From child to parent by emitting events. 3. From child to parent through a local variable in the parent's view #variable_name next to the child's html element. 4. From child to parent via parameter with @ViewChild decorator in component class. 5. By service. 6. Via Store if using NgRx.;1. Od parenta do childa przez propercje z dekoratorem Input(). 2. Od childa do parenta przez emittowanie eventów. 3. Od childa do parenta przez zmienną lokalną na widoku parenta #nazwa_zmiennej przy html elemencie dziecka. 4. Od childa do parenta przez parametr z dekoratorem @ViewChild w klasie komponentu. 5. Przez serwis. 6. Przez Store'a jeżeli używamy NgRx'a.;Angular;;true
What are Template Literals?;Template Literals is a format wrapped with backtick (`) characters, which allows for multiline strings and the ability to include variable values ​​in $ {} tags.;Template literals jest formatem określanym za pomocą znaków backtick(`), pozwalającym na multiline stringów i możliwością umieszczenia w nim wartości zmiennych w znacznikach ${}.;JavaScript;;true
What is interface? (interfejs);A structure that describes what methods and properties the objects will have inheriting from this structure.;Struktura, która opisuje jakie metody i propercje będzie miał obiekty dziedziczący po niej.;OOP;;true
What is Event Bubbling and if it works in Angular?;Event Bubbling is a propagation of an event up the DOM tree. If we have registered two events, e.g. click on the parent and on the child, then clicking on the child will start the child's event first, and then the parent's event. It works in Angular only for DOM events, custom events in the component do not propagate.;Event bubbling to propagowanie eventu w górę drzewa DOM. Jeżeli mamy zarejestrowane dwa eventy np. click na rodzicu i na dziecku to klikając w dziecko uruchomi się najpierw event dziecka, a później rodzica. Działa w Angularze tylko dla DOM eventów, customowe eventy w komponencie nie propagują.;Angular;;false
What is universal selector in CSS?;Is marked with asterisk. A universal selector is a selector that matches any element instead of selecting elements of a particular type.;Jest oznaczony gwiazdką. Selektor uniwersalny to selektor pasujący do dowolnego elementu zamiast wybierania elementów określonego typu.;CSS;;true
What are the ways of listening to DOM for Angular events?;1. Event Binding - one-way data binding in which information is sent from the Component view to its class. 2. @HostListener - Angular decorator, which handles events fired on the Component's host (it's selector). 3. Renderer2 - we use the Renderer2 .listen() function for the selected event and element. 4. RxJS - we use the RxJS operator .fromEvent() which turns events into sequential observable.;1. Event Binding - jednokierunkowy data binding, w którym informacja wysyłana jest z widoku Componentu do jego klasy. 2. @HostListener - decorator Angulara, który obsługuje eventy wywołane na host'cie Componentu (jego selectorze). 3. Renderer2 - używamy funkcji Renderer2 .listen() dla wskazanego eventu i elementu. 4. RxJS - używamy operatora RxJS .fromEvent(), który zamienia eventy w sekwencyjne observable.;Angular;;false
What is Barrel?;A way to collect exports from a couple of places in one convenient module export {Foo} from './app/foo'.;Sposób żeby zbierać exporty z pary miejsc w jeden wygodny moduł export { Foo } from './app/foo'.;Angular;;false
Whats the difference between @import and @use in SCSS.;Fundamentally both rules do the same thing - load members inside another module. The main differences is how they handle members. @import makes everything globally accessible in the target file. This enables an endless chain of imported files where it's difficult to trace where our variables and mixins are coming from. It also allows for overlap and makes it difficult to trace back why our css breaks. This is a problem especially with complex file structures and projects with multiple contributors and global libraries, which is why @import is no longer recommended by Sass. https://www.liquidlight.co.uk/blog/use-and-import-rules-in-scss/;Fundamentally both rules do the same thing - load members inside another module. The main differences is how they handle members. @import makes everything globally accessible in the target file. This enables an endless chain of imported files where it's difficult to trace where our variables and mixins are coming from. It also allows for overlap and makes it difficult to trace back why our css breaks. This is a problem especially with complex file structures and projects with multiple contributors and global libraries, which is why @import is no longer recommended by Sass. https://www.liquidlight.co.uk/blog/use-and-import-rules-in-scss/;CSS;;false
What is Transpiling in TypeScripcie?;Transpiling is the process of converting TypeScript to JavaScript.;Transpiling to proces konwertowania języka TypeScript do JavaScripta.;Angular;;false
What is the difference between a constructor and ngOnInit?;The constructor is called when the component class is created, ngOnInit is called after class creation is already finalized. The constructor should mainly be used for Dependency Injection and field assignments. ngOnInit is a Life Cycle Hook, called by Angular when the component is created. This is a better place to "start" because all the "hooks" in the component have already been set up.;Konstruktor jest wywoływany kiedy tworzona jest klasa Componentu, ngOnInit jest wywoływana jak tworzenie klasy już jest sfinalozowane. Konstruktor powinien być używany głównie do Dependency Injection i przypisania fieldów. ngOnInit to Life Cycle Hook, wywoływany przez Angulara, kiedy komponent zostanie już stworzony. Jest to lepsze miejsce "zaczęcia", ponieważ wszystkie "podpięcia" w komponencie zostały już ustawione.;Angular;;false
What are the elements of the form?;FormControl - tracks the value and state of a single input. FormGroup - Tracks the value and status of the FormControl group. The form is an input group, so FormGroup defines it.;FormControl - śledzi wartość i stan pojedyńczego inputa. FormGroup - śledzi wartość i stan grupy FormControli. Formularz jest grupą inputów, więc FormGroup definiuje go.;Angular;;false
What is NgRx?;NgRx is a combination of the Redux and Angular pattern - a library for organizing and managing state and state interactions in Angular applications. The goal of NgRx is to organize the state into one single local container, manage this state by requiring one-way data flow, communicate state changes to our components so that they can respond appropriately. NgRx manipulates the state whose parts (slices) are Immutable, which reduces the risk of generating errors in the application and facilitates the detection of changes.;NgRx to kombinacja wzorda Redux i Angulara - biblioteka do organizowania i zarządzania stanem i interakcjami ze stanem w aplikacjach Angulara. Celem NgRx jest organizacja stanu w jeden, pojedyźczy lokalny kontener, zarządanie tym stanem przez wymaganie jednostronnego przepływu danych, komunikowane zmiany stanu do naszych komponentów, żeby mogły odpowiednio reagować. NgRx manipuluje stanem, którego części (slice'y) są Immutable co zmniejsza ryzyko generowania błędów w aplikacji i ułatwia detekcję zmian.;Angular;;true
What is the manifest.webmanifest file for? (pwa manifest);The file is on the same level as index.html and is linked in there. It is one of the conditions for adding PWA functionality to the application. It defines how the installed icon of our PWA application will look like and some other UI parameters.;Plik znajduje się na tym samym poziomie co index.html i jest w nim linkowany. Jest jednym z warunków dodania funkcjonalności PWA do aplikacji. Określa jak zainstalowana ikona naszej aplikacji PWA będzie wyglądała oraz parę innych parametrów UI.;Angular;;false
What is a Decorator in Angular?;This is a function that adds metadata to a class, its properties, or its methods.;To funkcja, która dodaje metadane do klasy, jej propercji, lub jej metod.;Angular;;false
What is the difference between 'em' and 'rem' font size?;'em' is relative to the parent and 'rem' is relative to the base font size.;'em' jest względny do rodzica, a 'rem' do bazowego rozmiaru czcionki.;CSS;;false
What is Encapsulation?;One of the properties of object oriented programming. There are two main uses for encapsulation - hiding data and restricting access to data. The point is, we want the classes to be "loosly coupled" and only share data that they want to share with other classes in the system.;Jedna z właściwości programowania obiektowego. Są dwa główne zastosowania enkapsulacji - ukrywanie danych i ograniczanie dostępu do danych. Chodzi o to, że chcemy aby klasy były "luźno połączone" (loosly coupled) i udostępniały tylko te dane, które chcą dzielić z innymi klasami w systemie.;OOP;;true
What are the localStorage properties?;1. There is no expiration date (persistent storage), it can be removed from the code or browser settings. 2. Up to 10MB of data. 3. For use only on the client side, they are not sent to the server, unless we manually select the data to be sent. 4. Retain the so-called same-origin policy, which means that only code from the same address can access the data.;1. Nie ma daty wygaśnięcia (persistent storage), może zostać usunięte z poziomu kodu lub ustawień przeglądarki. 2. Do 10MB danych. 3. Do użytku tylko po stronie clienta, nie są wysyłane do servera, chyba, że ręcznie wybierzemy dane do wysłania. 4. Zachowują tzw. same-origin policy, co zonaczy, że tylko kod z tego samego adresu może uzyskać dostęp do danych.;JavaScript;;false
Is javascript a statically typed or a dynamically typed language?;JavaScript is a dynamically typed language. In a dynamically typed language, the type of a variable is checked during run-time in contrast to a statically typed language, where the type of a variable is checked during compile-time.;JavaScript to dynamicznie typowany język. W języku typowanym dynamicznym typ zmiennej jest sprawdzany w czasie działania(at run-time), w przeciwieństwie do języka o typowaniu statycznym, w którym typ zmiennej jest sprawdzany w czasie kompilacji.;JavaScript;;true
How is the ActivatedRoute class different from Router?;ActivatedRoute contains information about the route (route), and Router is a service for managing e.g. redirections.;ActivatedRoute zawiera informacje o ścieżce (route), a Router jest to serwis do zarządzania np. przekierowaniami.;Angular;;false
What is Karma and Jasmine in Angular?;Karma is a library for running Angular tests. Jasmine is a mocking tool, it makes sure the tests work the way we want through expectations.;Karma to biblioteka do uruchamiania testów w Angularze. Jasmine to narzędzie do tworzenia mocków, upewnia się, że testy działają tak jak chcemy poprzez expectations.;Testing;;true
What is metadata in HTML and how is it specified?;Metadata provides additional information about an HTML document. Its purpose is to help browsers, search engines and other web applications better interpret a document. Examples of metadata include the description, author, and keywords. The <meta> tag is used to define metadata about an HTML document. <meta> tags are always enclosed within the <head> of the HTML document.;Metadane dostarczają dodatkowych informacji o dokumencie HTML. Jego celem jest pomoc przeglądarkom, wyszukiwarkom i innym aplikacjom internetowym w lepszej interpretacji dokumentu. Przykłady metadanych obejmują opis, autora i słowa kluczowe. Znacznik <meta> służy do definiowania metadanych dotyczących dokumentu HTML. Tagi <meta> są zawsze zawarte w <head> dokumentu HTML.;HTML;;true
What are extension methods?;The extension method is a static method where the "this" modifier is used for the first parameter, which is the value to which we call the given extension method after the dot.;Extension method jest statyczną metodą, gdzie modyfikator "this" jest używany do pierwszego parametru, którym jest wartość, do której po kropce wywołujemy dany extension method.;OOP;;false
What are change detection strategies in Angular?;Default - checks all paths in the Component tree with each change, which may affect performance with more of them. OnPush - runs change detection for the Component and its children only when the reference of one of the Input() property has changed, or when the DOM element or one of its children emitted an Event.;Default - przy każdej zmianie sprawdza wszystkie ścieżki w drzewie Componentów, co może wpłynąć na wydajność przy większej ich ilości. OnPush - uruchamia detekcje zmian dla Componentu i jego dzieci tylko w przypadku, kiedy zmieniła się referencja jedna z propercji wejściowych Input() lub kiedy DOM element lub jeden z jego dzieci emitował Event.;Angular;;false
How is the markForCheck() function different from detectChanges() in ChangeDetectorRef?;markForCheck() mimics the "naturally" occurring change detection in Angular. This method lets Angular know there is a change he needs to check. The change is scheduled for execution when Angular is ready for it, so it is asynchronous. It also marks all parent views to be checked as if the @HostListener event worked. detectChanges() only checks the given view and works synchdonically - after each call on the next line, all changes (i.e. operations performed with lifecycle hooks) are already processed, thus it differs from a typical change detection process, so you should use only when we know what we want.;markForCheck() imituje "naturalnie" występujący change detection w Angularze. Ta metoda daje znać Angularowi, że jest zmiana, którą musi sprawdzić. Zmiana jest zaplanowana do wykonania kiedy Angular jest na nią gotowy, więc jest asynchdoniczna. Oznacza również wszystkie parent widoki do sprawdzenia, tak jakby @HostListener event zadziałał. detectChanges() tylko sprawdza dany widok i działa synchdonicznie - po każdym wywołaniu w następnej linijce wszystkie zmiany (tj. operacje wykonywane z lifecycle hook'ach) są już przeprocesowane, w ten sposób różni się od typowego systemu detekcji zmian, więc należy używać tylko w przypadku kiedy wiemy czego chcemy.;Angular;;true
What is the difference between Property Binding and Interpolation?;Angular converts the expression given in the interpolation to a string, so it is only used when we want to display or assign a string to the html code. Property binding does not convert the expression to a string, so if we want to assign some properties to a non-string value we use property binding.;Angular zamienia wyrażenie podane w interpolacji do stringa, więc jest ona używana tylko kiedy chcemy wyświetlić lub przydzielić string do kodu html. Property binding nie konwertuje wyrażenia do stringa, więc jeżeli chcemy przydzielić jakąś propercje do wartości nie-stringowej używamy property binding.;Angular;;false
What is an Immutability?;If object is Immutable, it means that its state cannot be changed after its creation.;Jeżeli object jest Immutable oznacza to, że jego stan nie może być zmieniony po jego utworzeniu.;Angular;;true
What is Continuous Integration(CI)?;Continuous Integration is a practice that consists in introducing changes to the code to the main repository as often and regularly as possible in order to avoid the so-called merge hell. In order to avoid related problems, such as the frequent generation of bugs or the incompilation of the walkthrough, automation is used to verify the correctness of the constructed project and the execution of tests.;Continuous Integration to praktyka polegająca na możliwie częstym i regularnym wprowadzaniu zmian w kodzie do głównego repozytorium żeby uniknąć tzw. merge hell. Żeby uniknąć związanych z tym problemów jak częstej generacji bugów albo niekompilowania się solucji stosuje się automatyzację weryfikującą poprawność zbudowanego projektu oraz wykonanie testów.;Angular;;true
What are dynamic components in Angular?;Dynamic components are components that are not directly specified in the view, they are created dynamically by the user while the application is running via ViewContainerRef.createComponent (f), to which we pass the component factory as a parameter (here f).;Dynamiczne komponenty to komponenty, które nie są bezpośrednio określane na widoku, tworzone są dynamicznie przez użytkownika w trakcie działania aplikacji poprzez ViewContainerRef.createComponent(f), do którego jako parametr podajemy factory komponentu (tutaj f).;Angular;;false
What is Symbol type? (type Symbol);One of the primitive types in JavaScript. A unique value usually used when we want to avoid name conflicts between properties or keys. So Symbol is used as an identifier for objects property. We can use it to e.g. keep metadata on an object. For example a case when we want to add identifier 'id' to object but it's been downloaded from backend and it already has such property, then we can add Symbol('id').;Jeden z typów prymitywnych w JavaScripcie. Unikatowa wartość używana zazwyczaj kiedy chcemy uniknąć konfliktów nazw pomiędzy propercjami lub kluczami. Więc Symbol jest używany jako identyfikator dla propercji obiektów. Możemy go używać żeby np. trzymać metadane na obiekcie. Np. w przypadku kiedy chcemy dodać identyfikator obiektu 'id', ale obiekt jest pobrany z backendu i posiada już taką propercję, wtedy możemy dodać Symbol('id').;JavaScript;;true
What are Generic Contraints?;Generic Constraints can restrict type that will replace our generic type T. They are like rules or instructions to define how to interact with a generic class or method. (extends, extends keyof);Genric Constraints mogą ograniczać typ, który zastąpi nasz typ generyczny T. Są jak reguły lub instrukcje definiujące sposób interakcji z klasą lub metodą generyczną. (extends, extends keyof);TypeScript;;true
What does AAA stand for when writing tests? (What is AAA);AAA stands for Arrange-Act-Assert, which outlines the steps when writing unit tests. First, we prepare the data - Arrange, then we run actions on this data - Act, then we check the obtained results - Assert.;AAA oznacza Arrange-Act-Assert, co określa kroki podczas pisania testów jednostkowych. Najpierw szykujemy dane - Arrange, następnie wywołujemy działania na tych danych - Act, następnie sprawdzamy otrzymane wyniki - Assert.;Testing;;true
What is MutationObserver?;MutationObserver is an interface for observing changes that occur in a specific node of the DOM tree.;MutationObserver jest interfejsem umożliwiającym obserwowanie zmian, które zachodzą w określonym nodzie drzewa DOM.;JavaScript;;true
What is an Immediately Invoked Function in JavaScript?;An Immediately Invoked Function (known as IIFE and pronounced as IIFY) is a function that runs as soon as it is defined.;Funkcja natychmiast wywołana (znana jako IIFE) to funkcja uruchamiana natychmiast po zdefiniowaniu.;JavaScript;;false
Why do we create Modules? (why Modules);As the application grows, new functionality begins to arrive, and thus - more components, services, directives, and many other things that need to be loaded into memory. This is where modules that are functional containers that can be independently loaded come in handy. Thus, when a user visits one section of the application, only files from that module will be loaded. Additionally, these are separate blocks of functionality that help understand the application architecture and maintain it.;Jak aplikacja rośnie, zaczyna przybywać nowej funkcjonalności, a co za tym idzie - więcej componentów, serwisów, dyrektyw i wiele innych rzeczy, które należy załadować do pamięci. Tutaj z pomocą wchodzą moduły, które są kontenerami funcjonalności mogących być niezależnie załadowanych. W ten sposób jak użytkownik odwiedzi jedną sekcję aplikacji tylko pliki z tego modułu zostaną załadowane. Dodatkowo są to odseparowane bloki funkcjonalności, które pomagają w przyswojeniu architektury aplikacji i utrzymywaniu jej.;Angular;;true
What does RouterModule provide?;-Router service that manages navigation, -route configuration options, -directives for activating and displaying routes, i.e. routerLink, routerLinkActive, router-outlet.;-serwis typu Router, który zarządza nawigacją, -opcje konfiguracji route'ów, -dyrektywy do aktywacji i wyświetlania route'ów, tj. routerLink, routerLinkActive, router-outlet.;Angular;;false
What would happen if we use many structural directives like *ngIf and *ngFor on a single element?;The exception will be thrown because we musn't use two or more structural directives on a single element.;Dostajemy błąd, ponieważ nie wolno używać dwóch strukturalnych dyrektyw na tym samym elemencie.;Angular;;false
What is CSS Ruleset?;[write better] The ruleset is used to identify that selectors can be attached with other selectors and it consists of two elements 1. One or more selectors 2. One or more declarations. The rule set is the main building block of a CSS sheet.;[napisać lepiej] Ruleset służy do identyfikacji, że selektory mogą być dołączone do innych selektorów i składa się z dwóch elementów 1. Jeden lub więcej selektorów 2. Jedna lub więcej deklaracji. Zestaw reguł jest głównym elementem składowym arkusza CSS. (zestaw regół);CSS;;true
What is SOLID? (principle);SOLID are good practices in object-oriented programming. S is for Single Responsibility Principle - a class should be responsible for one functionality. For example, there cannot be a class that Counts() and Cooks(). O for Open/Closed Principle - code must be open for extensions and closed for modifications. This means that you can change the behavior of an object without changing its code. It comes down to use of composition and IoC with DI. L comes from the Liskov Substitution Principle - the code should work properly with the class and all its subclasses. For example, a square is a triangle, but we cannot make square class that inherits from triangle class(square:triangle), because this violates this rule - if we put a square in the place where we expect a triangle, it may lead to unwanted consequences. I for Interface segregation principle - create as small interfaces as possible. Multiple dedicated interfaces are better than a generic one. D for Dependency inversion principle - High-level modules should not depend on low-level modules - the dependencies between them should be based on abstraction.;SOLID to są dobre praktyki w programowaniu obiektowym. S jak Single Responsibility Principle - klasa powinna byc odpowiedzila za jedną funkcjonalność. Np. nie może być klasy Urządzenie, która Liczy() i Gotuje(). O jak Open/Closed Principle - kod musi być otwarte na rozszerzania i zamknięty na modyfikacje. Oznacza to, iż można zmienić zachowanie takiego elementu bez zmiany jego kodu. Sprowadza się to do użycia kompozycji i IoC z DI. L pochodzi od Liskov Substitution Principle - kod powinien współpracować poprawnie z klasą, jak i wszystkimi jej podklasami. Np. kwadrat jest trójkątem, ale nie możemy zrobić kwadrat: trójkąt, ponieważ to naruszy tą zasadę - jeżeli w miejsce gdzie będziemy spodziewać się trójkąta podamy kwadrat to może prowadzić do niechcianych konsekwencji. I jak Interface segregation principle - tworzyć możliwie małe interface'y. Wiele dedykowanych interfejsów jest lepsze niż jeden ogólny. D jak Dependency inversion principle - Wysokopoziomowe moduły nie powinny zależeć od modułów niskopoziomowych - zależności między nimi powinny wynikać z abstrakcji.;OOP;;false
What is reducer? Can there be more than one reducer?;Reducer is simply a function that takes an action and the payload passed when that action was called, and replaces a certain part of the state accordingly. There can be more than one reducer, e.g. for each feature module I use at least one reducer, sometimes more.;Reducer jest po prostu funkcą, która pobiera akcję i dane przekazane przy wywołaniu tej akcji i odpowiednio podmienia określoną część stanu. Może być więcej niż jeden reducer, ja np. do każdego feature modułu używam przynajmniej jednego reducera, czasami więcej.;Angular;;false
When should <div> tags be used in HTML?;<div> should be used in HTML when no other semantically appropriate element is available. HTML5 introduces a number of new tags (such as <aside>, <footer>, and <header>) that take the place that <div> has traditionally occupied in previous HTML versions.;<div> powinien być używany w HTML, gdy nie jest dostępny żaden inny semantycznie odpowiedni element. HTML5 wprowadza szereg nowych tagów (takich jak <aside>, <footer> i <header>), które zajmują miejsce, które <div> tradycyjnie zajmowało w poprzednich wersjach HTML.;HTML;;true
Why do we use RouterModule.forRoot() in AppModule. and in the extra modules RouterModule.forChild()?;Because in addition to declaring the directives (ie routerLink, routerLinkActivate) and configuring the route table, forRoot also registers the Router service that we want to be provided only once in the application.;Ponieważ oprócz deklarowania dyrektyw (tj. routerLink, routerLinkActivate) i konfiguracji tablicy route'ów, forRoot dodatkowo rejestruje router service, który chcemy, żeby był providowany tylko raz w aplikacji.;Angular;;false
How do you design application? (application design, app design, design app);I plan the structure of the application in such way that: 1. We can quickly locate the code - that mean do not delve into nested folder structure to get to some functionality. Too flat structure is also very bad but we need to find balance. 2. We can identify the code at a glance. It is related to appropriate file naming. 3. Not repeating the code. 4. I try to create Components, Interfaces, Models in a way that they are responsible for one, specific functionality. So it would be Single Responsibility Principle. (describe smart/dumb components here too) 5. Very important is open/close principle - that tells us the class, a service for example, needs to be open to extensions but but closed for modifications. This is done by using Componsition and Dependency Injection. 6. I create smaller interfaces and models instead of larger ones. Multiple dedicated interfaces are better than generic ones.;Strukturę aplikacji planuję w taki sposób, aby: 1. Szybko zlokalizować kod - to znaczy nie zagłębiać się w zagnieżdżone struktury folderów, aby dostać się do jakiejś funkcjonalności. Zbyt płaska struktura jest również bardzo zła, ale musimy znaleźć równowagę. 2. Żeby na pierwszy rzut oka zidentyfikować kod. Wiąże się to z odpowiednim nazewnictwem plików. 3. Nie powtarzać kodu. 4. Staram się tworzyć Componenty, Interfejsy, Modele w taki sposób, aby odpowiadały za jedną, konkretną funkcjonalność. Byłaby to więc zasada pojedynczej odpowiedzialności. 5. Bardzo ważna jest zasada open/close - chodzi o to żeby klasa, na przykład Service, musi być otwarta na rozszerzenia, ale zamknięta na modyfikacje. Odbywa się to za pomocą kompozycji i Dependency Injection. 6. Tworzę mniejsze interfejsy i modele zamiast większych. Wiele dedykowanych interfejsów jest lepszych niż standardowe.;Angular;;true
How is ActivatedRoute different from ActivatedRouteSnapshot?;ActivatedRouteSnapshot is an immutable data structure representing the state of the router at a particular point in time. ActivatedRoute is something similar, except that it changes with the state of the router.;ActivatedRouteSnapshot jest niezmienną (immutable) strukturą danych, reprezentującą stan routera w konkretnym momencie. ActivatedRoute jest czymś podobnym, z wyjątkiem, że zmienia się ze stanem routera.;Angular;;false
What are Integration and Functional tests?;Integration and Functional tests are defined as tests on more than the "unit" and less than the entire application. So at least two units working together. This usually means checking if one part of the application is interoperable with another part of the application. These tests are quite a subjective term that can mean different things to different people.;Integracyjne i Funkcjonalne testy definionwane są jako testy na wiecej niż "unit'cie" i mniej niż całej aplikacji. Czyli co najmniej dwa unity pracujące razem. Zazwyczaj oznacza to sprawdzenie czy jedna część aplikacji współdziała z inną częścią aplikacji. Te testy są dość subiektywnym określeniem, które może znaczyć co innego dla różnych ludzi.;Testing;;true
What are the Higher-order mappings operators?;concatMap, mergeMap, switchMap, exhaustMap;concatMap, mergeMap, switchMap, exhaustMap;Angular;;false
What defines the structure of the application?;The final structure of the application is defined by the structure of Modules and the Dependency Injection pattern. The physical location of the files does not define the final structure of the application.;Ostateczną strukturę aplikacji definiuje struktura Modułów i wzorca Dependency Injection. Fizyczna lokalizacja plików nie definiuje ostatecznej struktury aplikacji.;Angular;;true
What is CSS Cascading? (Cascade);If the CSS Specificity value is the same, which style is more important is decided by the most important source where the rule is defined. The most important styles are: 1. Inline 2. Internal style sheets 3. External style sheets. 4. Default browser style sheets.;Jeżeli wartość CSS Specificity jest taka sama to o tym, który styl jest ważniejszy decyduje najważniejsze źródło gdzie jest dana zasada jest zdefiniowana. Najważniejsze są style: 1. Inline 2. Internal style sheets 3. External style sheets. 4. Default browser style sheets.;CSS;;true
What are Guards in Angularze?;Angular guards are nothing more than functionality, logic in code that is executed before going to route or before exiting it. The guards determine whether we can go to it or leave it.;Guardy w Angularze są niczym innym jak funkcjonalnością, logiką w kodzie, która jest wykonywana przed przejściem do route'a albo przed opószczeniem go. Guardy określają czy możemy do niego przejść lub czy go opuścić.;Angular;;false
How does 'overflow: hidden' work?;[write better] 'overflow: hidden' property is used to specify the content’s clipping. We may add scrollbars to the content area at the time of specified container size exceeding the content limit where the content gets enclosed. This makes the content invisible via clipping, also the overflow value will be hidden.;[napisać lepiej] Właściwość 'overflow: hidden' służy do określenia przycinania treści. Możemy dodać paski przewijania do obszaru zawartości w momencie, gdy określony rozmiar kontenera przekracza limit zawartości, w którym zawartość jest zamykana. Dzięki temu treść jest niewidoczna poprzez przycinanie, również wartość przepełnienia zostanie ukryta.;CSS;;true
What are the IndexedDB properties?;1. Up to 250MB. 2. IndexedDB API is asynchronous (unlike localStorage and sessionStorage). IndexedDB operations are event-driven by events like onsuccess, onerror, oncomplete, etc. 3. They have no persistent storage unless explicitly removed. 4. Retain the so-called same-origin policy, which means that only code from the same address can access the data.;1. Do 250MB. 2. IndexedDB API jest asynchroniczne (w odróżnieniu do localStorage i sessionStorage). Operacje IndexedDB są event-driven przez eventy jak onsuccess, onerror, oncomplete, itd. 3. Nie mają czasu wygaśnięcia (persistent storage) chyba, że jawnie usunięte. 4. Zachowują tzw. same-origin policy, co zonaczy, że tylko kod z tego samego adresu może uzyskać dostęp do danych.;JavaScript;;false
When to use and how does the async pipe work?;We put the async pipe in the view with the variable Observable. If we only want to display the returned value from the Observable, this is a very good solution, because async pipe will automatically subscribe to this Observable when creating a component and unsubscribe on destruction, reducing the amount of code and greater readability. If we need more control over the subscription then we don't use this pip, e.g. when we want to modify the returned value before displaying it in the view - then we use .subscribe().;Umieszczamy async pipe w widoku ze zmienną Observable. Jeśli chcemy wyświetlić tylko wartość zwróconą z Observable, jest to bardzo dobre rozwiązanie, ponieważ async pipe automatycznie zasubskrybuje ten Observable podczas tworzenia komponentu i odsubskrybuje po jego zniszczeniu, zmniejszając ilość kodu i zwiększając czytelność. Jeśli potrzebujemy większej kontroli nad subskrypcją to nie używamy tego pipa np. gdy chcemy zmodyfikować zwróconą wartość przed wyświetleniem jej w widoku – wtedy używamy .subscribe().;Angular;;true
Describe Adaptive Design.;1. Main focus is to develop a website in multiple fixed layout sizes. 2. Offers good control over the design to develop variation in screens. 3. It is very time-consuming and takes a lot of effort to build the best possible adaptive design as examining it will need to go for many options with respect to the realities of the end user.;1. Głównym celem jest stworzenie strony internetowej w wielu stałych rozmiarach. 2. Oferuje dobrą kontrolę nad designem w celu opracowania zmienności ekranów. 3. Zbudowanie możliwie najlepszego Adaptive Designu jest bardzo czasochłonne i wymaga wiele wysiłku, ponieważ badanie go będzie wymagało wielu opcji w odniesieniu do realiów użytkownika końcowego.;CSS;;false
How to add PWA functionality to the application?;It is best to install the @angular/pwa library, which will create for us all the necessary things needed for PWA functionality, that is: 1. Create a service worker with a default configuration. 2. It will create a manifest file that tells the browser how the application should behave during installation on the device. 3. Adds a link to the manifest in index.html.;Najlepiej zainstalować bibliotekę @angular/pwa, która stworzy za nas wszystkie niezbędne rzeczy potrzebne do funkcjonalności PWA, czyli: 1. Stworzy service workera z domyślną konfiguracją. 2. Stworzy plik manifest, który mówi przeglądarce jak aplikacja ma się zachowywać podczas instalacji na urządzeniu. 3. Dodaje link do manifestu w index.html.;Angular;;true
What is prototype?;Prototype is the mechanism by which JavaScript objects inherit functionality from one another. It's a proper function that every JavaScript function has that points to an object that allows methods to be shared across all function instances. TypeScript is used in Angular and I have not yet encountered the need to use a prototype.;Prototype jest mechanizmem, dzięki któremu JavaScriptowe obiekty dziedziczą funkcjonalności między sobą. Jest to propercja, którą posiada każda stworzona funkcja w JavaScripcie, która wskazuje na obiekt pozwalający dzielić metody pomiędzy wszystkimi instancjami funkcji. W Angularze używany jest TypeScript i nie spotkałem się jeszcze z przypadkiem potrzeby używania prototypu.;JavaScript;;false
What is a Component host element? (Component selector);A Component's host element is an external element containing a Component's template, which has a tag corresponding to the value set as selector in the Component's decorator.;Host element Componentu jest zewnętrznym elementem zawierającym widok (template) Componentu, który ma tag odpowiadający wartości ustawianej jako selector w dekoratorze Componentu.;Angular;;false
What is HTML?;HTML means HyperText Markup Language. It is a language for developing web pages to display on the web browser. The file extensions used to save HTML pages are .html and .htm.;HTML oznacza HyperText Markup Language. Jest to język do tworzenia stron internetowych, które mają być wyświetlane w przeglądarce internetowej. Rozszerzenia plików używane do zapisywania stron HTML to .html i .htm.;HTML;;false
What is Cross Origin Resource Sharing (CORS)?;From the beginning of web pages, browsers limited applications to make requests to pages other than from which the application came. Modern browsers define how you can manage where your application code can reach. In Angular itself, you do not need to change anything explicitly, because Angular's HttpClient service will take care of sending the appropriate headers by itself.;Od początku stron internetowych przeglądarki ograniczały aplikacje do robienia requestów do innych stron niż z których dana aplikacja przyszła. Współczesne przeglądarki określaja w jaki sposób można zarządzać gdzie kod aplikacji może sięgać. W samym Angularze nie trzeba nic jawnie zmianiać, ponieważ serwis HttpClient Angulara sam zadba o przesyłanie odpowiednich headers'ów.;Angular;;true
What are Web Sockets?;WebSocket API is a technology that enables the opening of a two-way communication link between the client (user's browser) and the server. Through this API, you can send messages to the server and receive events from the server without the need to send a query.;WebSocket API to technologia, która umożliwia otwardzie dwustronnego (two-way) połączenia komunikacyjnego pomiędzy klientem (user's browser) i serwerem. Poprzez to API możesz wysyłać wiadomości do serwera i odbierać eventy z serwera bez potrzeby wysłania zapytania.;Angular;;true
What are the differences between TypeScript and JavaScript? (typescript javascript difference, javascript typescript difference);1. TypeScript has better Object-oriented functionalities like Generics, Clases, Interfaces, and JavaScript doesn't. 2. TypeScript has Static typing, JavaScript does not. 3. TypeScript supports optional function parameters, JavaScript does not. 4. TypeScript supports Interfaces but JavaScript does not.;1. TypeScript jest Object-oriented językiem, a JavaScript Scripting językiem. 2. TypeScript ma Statyczne typowanie (Static typing), JavaScript nie. 3. TypeScript supportuje moduły, JavaScript nie. 4. TypeScript wspiera opcjonalne parametry funkcji, JavaScript nie.;TypeScript;;true
Why do we need Immutability?;Immutability helps in detecting and preventing many kinds of errors in the application, especially as the application has many asynchronous elements. Often in my work I had a case where I didn't know why the proper function of a given object had this value and not another, it was hard to track down what changes it and where, because the reference of this object was passed somewhere before, usually asynchronously, and some completely different asynchronous process changed its proper functions. If we were following the Immutability principle, then the potential asynchronous process would not change the object in my thread, but operate on a copy of the object, and the data in my process would not be erroneously changed. Often in Angular, changes are detected only when the entire object under the reference changes, and not some variable inside, e.g. in NgRx, reducers change the entire object of a state part, not a fragment of an object, or the change detection method would react somehow each time a variable inside an object with the @Input decorator will change, not how the whole object underneath changes. Besides, it is more efficient to observe if the reference pointer has changed than to check if any variable in the structure that the reference points to has changed.;Immutability pomaga w wykryciu i zapobiega wielu rodzajom błędów w aplikacji, szczególnie jak aplikacja ma wiele elementów asynchronicznych. Często w pracy miałem taki przypadek, że nie wiedziałem dlaczego propercja danego obiektu posiada taką wartość, a nie inną, ciężko było wyśledzić co ją zmienia i w którym miejscu, ponieważ referencja tego obiektu została wcześniej gdzieś przekazana, zazwyczaj asynchronicznie, i jakiś zupełni inny proces asynchroniczny zmianiał jej propercje. Jeżeli kierowalibyśmy się zasadą Immutability, wtedy potencjalny proces asynchroniczny nie zmieniałby obiektu z mojego wątku, tylko operowałby na kopii obiektu, przez co dane w moim procesie nie ulegałyby błednej zmianie. Często w Angularze zmiany wykrywane są dopiero w przypadku jak zmieni się cały obiekt pod referencją, a nie jakaś zmienna w środku, np. w NgRx reducery zmieniają cały obiekt części stanu, a nie fragment obiektu, albo metoda detekcji zmian reagowałaby za każdym razem jak jakaś zmienna wewnątrz obiektu z dekoratorem @Input się zmieni, a nie jak zmieni się cały obiekt pod spodem. Poza bardziej wydajnie jest obserować czy wskaźnik referencji się zmienił, niż sprawdzać czy jakakolwiek zmienna w strukturze, na którą wskazuje referencja uległa zmianie.;Angular;;true
What is BEM?;Block Element Modifier - CSS class naming method .block__element--modifier. In BEM, block is a separate, independent component, the element is part of the block and is dependent on it. A modofier is a flag that we can put on a block or element to distinguish it from regular blocks or elements, e.g. recipe__button--round.;Block Element Modifier - sposób nazewnictwa klas w CSS na zasadzie .block__element--modifier. W BEM block jest oddzielnym, niezależnym komponentem, element jest częścią blocku i jest od niego zależny. Modofier jest flagą, którą możemy nałożyć na block albo element żeby odróżnić ich od zwykłych blocków lub elementó, np .recipe__button--round.;CSS;;true
What is Aggregation?;Aggregation is simply when an object consists of other types. In aggregation, one object contains another object that is its component. Contrary to composition, component objects can exist without the main object, eg a car contains an engine, tires, etc.;Z agregacją mamy doczynienia, kiedy obiekt składa się z innych typów, po prostu. W agregacji jeden obiekt zawiera inny obiekt, który jest jego składową. W odróżnieniu od kompozycji obiekty składowe mogą istnieć bez obiektu głównego, np. Samochód zawiera silnik, opony, etc.;OOP;;false
What is Angular Material?;Angular Material is a User Interface (UI) component library that developers can use in their Angular projects to speed up the development of elegant and consistent user interfaces.;Angular Material to biblioteka komponentów interfejsu użytkownika (UI), której programiści mogą używać w swoich projektach Angular, aby przyspieszyć tworzenie eleganckich i spójnych interfejsów użytkownika.;Angular;;true
What are the disadvantages of monorepo?;1. Access to projects (project access) - In monorepo, everyone has access to the workspace with all projects, so there is a problem with restricting access to individual projects because they are part of the same repository. 2. Each project in monorepo must have the same version, which means that if we wanted to list one project, the version of each project would be updated. 3. Workspace size - each developer working in each project would have to download the entire repository and install all dependencies from each project.;1. Dostęp do projektów (project access) - W monorepo każdy ma dostęp do workspace'a ze wszystkimi projektami, więc jest problem z ograniczaniem dostępu do poszczegółnych projektów, ponieważ są częścią tego samego repositorium. 2. Każdy projekt w monorepo musi posiadać tą samą wersję, co oznacza, że jeżeli chcielibyśmy wystawić jeden projekt, wersja każdego projektu zostałaby uaktualniona. 3. Rozmiar workspace'a - każdy developer pracujący w każdym projekcie musiałby pobrać całe repozytorium i instalować wszystkie zależności z każdego projektu.;Angular;;false
Why NgRx? (NgRx advangates, NgRx benefits);Makes the application much more maintainable as it separates the business logic from the application presentation layer. It also facilitates debugging and error detection because whole state is immutable and has one way data flow. The entire state is also clearly presented on Redux DevTools in the browser, and additionally, each action is logged in it and easy to track.;Powoduje, że aplikacja jest dużo bardziej utrzymywalna poniważ oddziela (decouples) logikę biznesową od warstwy prezentacyjnej aplikacji. Ułatwia również debugowanie i wykrywanie błędów ponieważ cały state jest immutable i posiada jednokierunkowy przepływ danych. Cały stan mamy też w przejrzysty sposób przedstawiony na Redux DevTools w przeglądarce, a dodatkowo każda akcja jest w nim logowana i łatwo ją wyśledzić.;Angular;;true
What are the sessionStorage properties?;1. Data only live in the context of one tab. 2. Up to 10MB of data. 3. For use only on the client side, they are not sent to the server, unless we manually select the data to be sent. 4. Retain the so-called same-origin policy, which means that only code from the same address can access the data.;1. Dane żyją tylko w kontekście jednego taba. 2. Do 10MB danych. 3. Do użytku tylko po stronie clienta, nie są wysyłane do servera, chyba, że ręcznie wybierzemy dane do wysłania. 4. Zachowują tzw. same-origin policy, co zonaczy, że tylko kod z tego samego adresu może uzyskać dostęp do danych.;JavaScript;;true
How does Preloading (Eager Lazy Loading) work?;First, all imported modules are run, the rest are downloaded from the back-end in the background.;Najpierw uruchamiane są wszystkie zaimportowane moduły, pozostałe zaciągane są z back-endu w tle.;Angular;;false
What is ViewEncapsulation?;ViewEncapsulation decides whether the styles defined in the component can affect the entire application or not.;ViewEncapsulation decyduje czy style zdefinionwane w komponencie mogą mieć wpływ na całą aplikację czy nie.;Angular;;true
What is 'never' type in TypeScript?;We get the 'never' type when the function never returns anything, e.g. it will never finish its operation or it will always throw an exception, it will be marked as returning the type never.;Typ 'never' otrzymujemy kiedy funkcja nigdy nic nie zwróci, np. nigdy nie skończy swojego działania albo zawsze wyrzuci wyjątek, zostanie oznaczona jako zwracająca typ never.;TypeScript;;false
What does routerLinkActivate do? (What is routerLinkActivate);It sets a specific class for an element if we are in the route described in [routerLink].;Ustawia nazwę klasy, jeżeli jesteśmy w ścieżce podanej w atrybucie [routerLink].;Angular;;false
What is "providers" property in module metadata?;It is a table of all services that should be provided by the module's Injector. In the documentation, provier is described as a recipe for delivering the service specified by the token.;To tablica wszystkich serwisów, które powinny być zapewnione przez Injector modułu. W dokumentacji provier jest opisany jako recepta na dostarczanie serwisu określonego przez token.;Angular;;true
What does :host, :host-context([selector]), ::ng-deep in css in Angular?;:host selects the element that called the component, eg <app- [component_name]>, and adds styles to it. If we want to check if this element has any class, we do for example :host(.how-class). :host-context selects the item that triggered the given component that is wrapped in the item in [selector]. ::ng-deep imposes styles on the template and child components.;:host zaznacza element, który wywoływał dany komponent, np <app-[nazwa_komponentu]> i dodaje do niego style. Jeżeli chcemy sprawdzić czy ten element ma jakąś klasę to robimy np. :host(.jakas-klasa). :host-context zaznacza element, który wywoływał dany kompoment, który jest owrapowany w element w [selectorze]. ::ng-deep narzuca style do template'a oraz do child componentów.;Angular;;false
What are Lifecycle Hooks for Angular Components?;1. The constructor is run 2. If there is any Input() then we call the ngOnChanges() method and then each time this Input() changes 3. ngOnInit() - initializes the component, launched right after the first display of proper functions with data binding the view with component class (data-bound properties) 4.ngDoCheck() every time the change detection mechanism is started 5.ngAfterContentInit() - run once after the first ngDoCheck () 6.ngAfterContentChecked() run once after ngAfterContentInit() and each time after ngDoCheck() 7. ngAfterViewInit() run once after the first ngAfterContentChecked() 8. ngAfterViewChecked() run once after ngAfterViewInit () and each time after ngAfterContentChecked() 9. ngOnDestroy() - run before the component is destroyed.;1. Uruchamiany jest konstruktor 2. Jeżeli jest jakiś Input() to wywołujemy metodę ngOnChanges() i później za każdym razem jak się ten Input() zmieni 3. ngOnInit()- inicjalizuje komponent, uruchamiany zaraz po pierwszym wyświtlenium propercji z danymi wiążącymi widok z klasą komponentów (data-bound properties) 4. ngDoCheck() przy każdym uruchomieniu mechanizmu detekcji zmian 5. ngAfterContentInit() - uruchamiane raz po pierwszym ngDoCheck() 6. ngAfterContentChecked() uruchamiane raz po ngAfterContentInit() i za każdym razem po ngDoCheck() 7. ngAfterViewInit() uruchamiane raz po pierwszym ngAfterContentChecked() 8. ngAfterViewChecked() uruchamiane raz po ngAfterViewInit() i za każdym razem po ngAfterContentChecked() 9. ngOnDestroy() - uruchamiane tóż przed zniszczeniem componentu.;Angular;;true
What is NX?;NX is a set of tools for monorepos, which are repositories that contain multiple projects. It is particularly useful for frontend applications because it allows for better organization and management of code across multiple projects and libraries. NX helps with tasks such as building, testing, and deploying code, as well as managing dependencies and enforcing consistent code conventions across projects.;NX to zestaw narzędzi dla monorepo, czyli repozytorium zawierającym wiele projektów. Jest to szczególnie przydatne w aplikacjach frontendowych, ponieważ pozwala na lepszą organizację i zarządzanie kodem w wielu projektach i bibliotekach. NX pomaga w zadaniach, takich jak budowanie, testowanie i wdrażanie kodu, a także zarządzanie zależnościami i wymuszanie spójnych konwencji kodu w projektach.;Angular;;true
What are JavaScript Modules? (JavaScript moduły / moduły JavaScript);Modules allow us to break up our code into separate files. Everything with 'export' prefix can be called JavaScript module and we can import it in other file later on.;Moduły pozwalają nam podzielić nasz kod na osobne pliki. Wszystko z przedrostkiem „export” można nazwać modułem JavaScript i możemy to później zaimportować w innym pliku.;JavaScript;;true
What are the features in JavaScript ES6? (es6 features, features es6);1. let 2. const 3. Arrow functions 4. Spread operator (...) 5. New loop: for (item of items) 6. Map 7. Set 8. Classes 9. Promises 10. Symbol 11. Default function parameters 12. Function rest parameters: function sum(...args) 13. String.includes(), String.startsWith(), String.endsWith() 14. Array.from(), Array keys(), Array find(), Array findIndex() 15. Object entries 16. JavaScript Modules 17. Classes;1. let 2. const 3. Arrow functions 4. Spread operator (...) 5. New loop: for (item of items) 6. Map 7. Set 8. Classes 9. Promises 10. Symbol 11. Default function parameters 12. Function rest parameters: function sum(...args) 13. String.includes(), String.startsWith(), String.endsWith() 14. Array.from(), Array keys(), Array find(), Array findIndex() 15. Object entries 16. JavaScript Modules 17. Classes;JavaScript;;true
How to compare two objects in TypeScript/JavaScript? (object comparison/objects comparison);1. Use JSON.stringify() to compare objects whose keys are in the same order. 2. Do a shallow comparison if the objects are not nested - just check if length of Object.keys is the same and each property is equal to others object property. 3. Use lodash.isEqual to test for deep equality of objects.;1. Używay JSON.stringify() do porównania obiektów, których klucze są w tej samej kolejności. 2. Robimy shallow comparison, jeśli obiekty nie są zagnieżdżone - po prostu sprawdź, czy długość Object.keys jest taka sama, a każda właściwość jest równa właściwościom innego obiektu. 3. Użyj lodash.isEqual, aby przetestować głęboką równość obiektów.;TypeScript;;true
What is TypeScript instanceof type guard?;instanceof is an operator in TypeScript, which checks if an object is an instance of a specific class. The Instanceof also takes inheritance into account. It returns true if the object appears anywhere in the inheritance chain. It doesn't work for primitive types. instanceof also acts as a Type Guard, helping us infer the type correctly in the scope: function getCode(obj: Person) { if (obj instanceof Customer) { obj.code() } else if (obj instanceof SalesPerson) { obj.code() } };instanceof jest operatorem w TypeScript'cie, który sprawdza czy obiekt jest typem określonej klasy. instanceOf bierze pod uwagę dziedziczenie. Zwraca true jeżeli obiekt występuje gdziekolwiek w łańcuchu dziedziczenia. Nie działa dla typów prymitywnych. instanceof działa również jako Type Guard, pomagając rozróżnić poprawny typ w naszym scopie: function getCode(obj: Person) { if (obj instanceof Customer) { obj.code() } else if (obj instanceof SalesPerson) { obj.code() } };TypeScript;;true
How cherry-pick works? (cherry pick/cherrypick);Through cherry-pick, we select a commit from one branch and apply it to another.;Poprzez cherry-pick wybieramy commit z jednego brancha i nakładamy go na inny.;OOP;;true
What is Git?;Git is a DevOps tool used for source code management. Version control system used to handle small to very large projects efficiently. Git is used to tracking changes in the source code, enabling multiple developers to work together.;Git jest narzędziem devopsowym używanym do zarządzania kodem aplikacji. System kontroli wersji dla projektów każdej wielkości. Git jest używany do śledzenia zmian w kodzie, umożliwiając wielu deweloperom wspólną pracę.;OOP;;true
How rebase works? How does it differ from merge?;If we want to merge, for example, a feature branch with a master branch, rebase moves the commits from the feature branch and appends them to the front of the master branch. Merge, on the other hand, combines these two branches with the history that took place when committing specific commits.;Jeżeli chcemy złączyć np. feature branch z master brancha rebase przesuwa commity z feature brancha i dołącza je z przodu master brancha. Merge natomiast łączy te dwa branche z historią jaką miała ona miejsce podczas commitowania konkretnych commitów.;OOP;;true
What is a Code Review and how do you do it? (codereview);Code Review is a process that requires developers to have their work reviewed by their peers. The goal of this evaluation is to identify bugs, syntax issues, and something that would affect the application’s performance. When I do a Code Review I check: 1. If Variables and Functions names are descriptive. 2. If there's separation of concerns, that is - if functionality is separated into distinct blocks so that each block is responsible for single, concrete thing. 3. If the path aliases are used, for example: not  ../../../shared/components/reusable/shared.component.ts but @app/shared/components/shared.component.ts 4. Code should be readable without comment. 5. If there are routes whose modules should be lazy loaded. 6. Proper encapsulation in object's properties and methods. 7. Don't Repeat Yourself rule - if functionality is not unnecessarily repeated. 8. All subscriptions are unsubscribed in proper places to avoid memory leaks.;Code Review jest procesem, w którym developerzy po ukończeniu funkcjonalności przeglądają swój kod. Celem tego jest wykrycie potencjalnych błędów, problemów składniowych, wykrycie czegoś co potencjalnie zaszkodziłoby wydajności aplikacji. Kiedy robię Code Review sprawdzam: 1. Czy zmienne i funkcje nazwane są opisowo. 2. Czy jest tzw. separation of concerns, tzn. czy funkcjonalność jest podzielona na oddzielne bloki, w których każdy blok jest odpowiedzialny za pojedyńczą, konkretną rzecz. 3. Czy używane są aliasy zamiast długich ścieżek, np. nie ../../../shared/components/reusable/shared.component.ts ale @app/shared/components/shared.component.ts. 4. Kod powinien być czytelny bez komentarzy. 5. Czy są routy, których moduły powinny być lazy loadowane. 6. Odpowiednia enkapsulacja propercji i metod obiektów. 7. Czy funkcjonalność nie powtarza się niepotrzebnie. 8. Wszystkie subskrypcje są odsubskrybowane w odpowiednich miejscach, żeby uniknąć 'przecieków' pamięci.;OOP;;true
What is Reactive programming? (programowanie reaktywne/reaktywne programowanie);Reactive programming is a way of asynchronous programming that uses data streams and appropriate propagation of changes. In Angular RxJs is used to code reactively. We try to make our streams of data from source to exit which is typically the template we want to display that data on. The point is that throughout the entire 'journey' from source to exit we never subscribe to the stream - we only subscribe to the stream when we want to pull our data when we reach the destination which is often the template using async pipe. The main benefit for me is that if everyone is based on streams then, wherever any data changes everything just updates automatically wherever it needs to. When we are building application we are often dealing with changing data and with RxJs everything seems to be working as it should and we don't have to manually update things all the time.;Programowanie reaktywne to sposób programowania asynchronicznego polegające na strumieniach danych i odpowiedniej propagacji zmian. W Angularze do programowanie reaktywnego używany jest RxJs. Staramy programować nasze strumienie danych od samego źródła do wyjścia, którym jest zazwyczaj template do wyświetlenia danych. Chodzi o to, aby przez całą podróż od źródła do wyjścia strumień danych nie był oddzielnie subskrybowany - jedynie subskrybujemy jeżeli chcemy wyciągnąć nasze dane kiedy osiągniemy docelowe miejsce, którym zazwyczaj jest template przy pomocy async pipeu. Główną zaletą dla mnie jest to, że jeżeli wszystko opiera się na strumieniach danych to jeżeli jakiekolwiek dane się zmienią wszystko aktualizuje się automatycznie gdzie jest na to potrzeba. Podczas budowania aplikacji często zmieniamy dane i przy pomocy RxJs wszystko wydaje się działać tak jak powinno i nie potrzebujemy nic ręcznie aktualizować.;Angular;;true
How do you apply SOLID in Angular?;1. Single responsibility - object should be responsible for only one functionality. We divide functionality properly between Components, Services, and Models. For example we don't define our header, content, and footer in our AppComponent, we split the code into separate components. 2. Open/Closed Principle - code must be open for extensions and closed for modifications. This means that you can change the behavior of an object without changing its code. It comes down to use of composition and IoC with DI. In Angular we use it for example by creating reusable Components that we can reuse without modifying their code. 3. Liskov Substitution Principle - the code should work properly with the class and all its subclasses. It's about inheritance. If we create for example a BaseService that other ChildServices will inherit from we need to make sure that code that injects BaseService will be working well with all ChildServices. I used such approach when I created for exampe GenericTable that was using BaseGenericTableService and there were different GenericTableService for different table. 4. Interface segregation principle - multiple dedicated interfaces are better than a generic one. For example we don't create one generic interface for backend response properties and frontend model properties because we will create a hard to maintaine mess, instead we create one interface for backend response and one for frontend model and map the values. 5. Dependency inversion principle - High-level modules should not depend on low-level modules - the dependencies between them should be based on abstraction. We apply this design principle each time we use Depenency Injection. When we inject into Component for example ProductService it doesn't mean that the ProductService class ProductService will be used. Angular creates so called Injector which acts like abstraction layer, so our Component does not depend on ProductService directly. Our Injector injects the object it has defined under the ProductService token, it can be completely different class.;1. Single responsibility - obiekt powinien odpowiadać tylko za jedną funkcjonalność. Właściwy podział funkcjonalności między Componenty, Servicy i Modele. Na przykład nie definiujemy naszego headera, contentu i footera w naszym AppComponentcie, dzielimy kod na osobne Componenty. 2. Open/Closed Principle - kod musi być otwarty na rozszerzenia i zamknięty na modyfikacje. Oznacza to, że możemy zmienić zachowanie obiektu bez zmiany jego kodu. Sprowadza się to do użycia kompozycji i IoC z DI. W Angular używamy go na przykład tworząc Componenty wielokrotnego użytku, które możemy ponownie wykorzystać bez modyfikowania ich kodu, np. używając <ng-contenty> albo Property Binding. 3. Liskov Substitution Principle - kod powinien działać poprawnie z klasą i wszystkimi jej podklasami. Chodzi o dziedziczenie. Jeśli stworzymy na przykład serwis, który się nazywa BaseService, po którym inne serwisy potomne będą dziedziczyć, musimy upewnić się, że kod injectujący BaseService będzie dobrze działał ze wszystkimi serwisami potomnymi. Zastosowałem takie podejście, gdy stworzyłem na przykład GenericTableComponent, który korzystał z BaseGenericTableService i istniały różne GenericTableServicey dla różnych tabel, a Component poprawnie działał dla ich wszytkich. 4. Interface segregation principle - wiele dedykowanych interfejsów jest lepszych niż jeden ogólny. Na przykład nie tworzymy jednego ogólnego interfejsu z propercjami responsa backendowego i propercjami modelu frontendu, ponieważ stworzymy trudny do utrzymania bałagan, zamiast tego tworzymy jeden interfejs dla odpowiedzi backendu i jeden dla modelu frontendu i mapujemy wartości. 5. Dependency inversion principle - Moduły wysokiego poziomu nie powinny zależeć od modułów niskiego poziomu - zależności między nimi powinny być oparte na abstrakcji. Stosujemy tę zasadę za każdym razem, gdy używamy Depenency Injection. Kiedy wstrzykniemy do Component np. ProductService, nie oznacza to, że zostanie użyta klasa ProductService. Angular tworzy tzw. Injector, który działa jak warstwa abstrakcji, dzięki czemu nasz komponent nie jest bezpośrednio zależny od ProductService. Nasz Injector wstrzykuje obiekt, który zdefiniował pod tokenem ProductService, może to być zupełnie inna klasa.;Angular;;true
What is npm?;npm stands for Node Package Manager. It’s a registry for JavaScript software packages, a repository for the publishing of open-source projects. It also has command-line tools to help us install  different packages.;Node Package Manager, w skrócie npm. To rejestr packagey JavaScript, repozytorium do publikowania projektów open source. Ma również narzędzia wiersza poleceń, które pomogą nam w instalacji różnych pakietów.;JavaScript;;false
What is Node.js?;Node.js is a runtime environment that allows you to run JavaScript on the backend. It provides all the functionality needed for a program to run.;Node.js to środowisko, które umożliwia uruchamianie JavaScript na backendzie. Zapewnia wszystkie funkcje potrzebne do uruchomienia programu.;JavaScript;;true
Why use npm? (why npm, dlaczego npm);It’s possible to manage our project’s dependencies ourself. But as our project grows this can become a problem. This is where a package manager like npm comes in. npm solves this problem by handling dependency and package management for our project. We define all our project’s dependencies inside our package.json file. Anytime we or a team member needs to get started with our project, all they have to do is run npm install. This will immediately install all the necessary dependencies for our project. In the package.json file, we can also specify which versions our project depends upon.;Możliwe jest samodzielne zarządzanie zależnościami projektu. Ale w miarę rozwoju projektu może to stać się problemem. W tym pomaga package manager, taki jak npm. npm rozwiązuje ten problem, zajmując się zależnościami i zadządzając packagami dla naszego projektu. Definiujemy wszystkie zależności swojego projektu w pliku package.json. Za każdym razem, gdy członek zespołu musi rozpocząć pracę nad projektem, wystarczy uruchomić npm install. Spowoduje to natychmiastowe zainstalowanie wszystkich niezbędnych zależności dla projektu. W pliku package.json moża również określić, od których wersji zależy projekt.;JavaScript;;true
What is a package.json?;A package.json file is created by a node package manager and exists at the root of a project. The file is in JSON format and is used for managing the project’s dependencies, versions, etc.;Plik package.json jest tworzony przez node package managera i istnieje w katalogu głównym projektu. Plik jest w formacie JSON i służy do zarządzania zależnościami projektu, wersjami itd.;JavaScript;;true
Dependencies vs. devDependencies what’s the difference?;There are two properties for dependencies in a package.json file, dependencies and devDependencies. 1. Dependencies are the list of packages that are required for your project to run. These are installed using npm install. 2. devDependencies, short for development dependencies, are packages that are NOT required for your project to run. These are often things that help the development process but aren’t part of the project themselves. For example, linters like eslint, testing, etc.;Istnieją dwie propercje do dependency w pliku package.json, dependencies i devDependencies. 1. Dependencies to lista packagey wymaganych do uruchomienia projektu. Są one instalowane za pomocą npm install. 2. devDependencies, skrót od development dependencies, to package'e, które NIE są wymagane do uruchomienia projektu. Często są to rzeczy, które pomagają w procesie programowania, ale same w sobie nie są częścią projektu. Na przykład lintery, takie jak eslint, testowanie itp.;JavaScript;;true
What is semantic versioning? (wersjonowanie semantyczne);Versions are described in format MAJOR.MINOR.PATCH. MAJOR version involves breaking changes. MINOR version change is backward compatibile, meaning it should update without breaking things. PATCH version change is backwards compatibile bug fixes, or other small flaws.;Wersje są opisane w formacie MAJOR.MINOR.PATCH. Wersja MAJOR zawiera istotne zmiany. Zmiana wersji MINOR jest kompatybilna wstecz, co oznacza, że ​​powinna aktualizować się bez psucia aplikacji. Zmiana wersji PATCH to wstecznie kompatybilna poprawka błędów lub innych drobnych usterek.;JavaScript;;true
npm install vs. npm ci what's the difference?;npm install 1. Will create a package-lock.json if there isn’t one already. 2. Upgrades to the latest version of a package with the ^ version sign. 3. Can install individual dependencies via npm install <package-name>. 4. Updates existing node_modules. 5. Can write to an existing package-lock.json. npm ci 1. Must have an existing package-lock.json. 2. Will not update the package lock if the dependencies do not match, instead will exit in error. 3. Can only install entire project, not individual dependencies. 4. Always removes node_modules and starts fresh. 5. Will never write to package.json or any of the package-locks: installs are frozen.;npm install 1. Stworzy package-lock.json jeżeli nie jest stworzony. 2. Aktualizuje do najnowszej wersji package'e ze ^ przy wersji. 3. Może zainstalować niezależne dependencies przez npm install <nazwa-package'a>. 4. Aktualizuje istniejący node_modules. 5. Can write to an existing package-lock.json. 5. Może wyedytować istniejący package-lock.json. npm ci 1. Musi być już stworzony package-lock.json. 2. Nie zaktualizuje package-lock.js jeżeli dependencies nie pasują, zamiast tego wyrzuci error. 3. Może tylko zainstalować package'a z całego projektu, nie pojedyńczy dependency. 4. Zawszed usuwa node_modules i zaczyna na nowo. 5. Nigdy nie wyedytuje package.json ani package-lock.json.;JavaScript;;true
What makes a good package?;1. Is the project still maintained? I look at the last time it was updated. 2. How many weekly downloads? If I'm using a package in a business setting, I want to make sure it’s reputable. More people using it means more eyes on the code means more chances the bugs have already been sorted out. 3. How’s the documentation? When I get stuck, it’s really helpful if the package has good documentation, otherwise I'm shooting alone in the dark. 4. Does it have a community? I can check the package’s Github issues, are they active? It’s good to have somewhere to go for help if need be. 5. License.;1. Czy projekt jest nadal utrzymywany? Patrzę na ostatnią aktualizację. 2. Ile pobrań tygodniowo? Jeśli korzystam z pakietu w środowisku biznesowym, chcesz mieć pewność, że jest godny zaufania. Więcej osób korzystających z niego oznacza więcej oczu na kod, co oznacza większe szanse, że błędy zostały już rozwiązane. 3. Jak wygląda dokumentacja? Kiedy utknę, naprawdę pomocne jest, jeśli pakiet ma dobrą dokumentację, w przeciwnym razie kręcisz sam w ciemności. 4. Czy ma community? Mogę sprawdzić problemy z pakietem Github, czy są aktywne? Dobrze jest mieć gdzie się udać po pomoc w razie potrzeby. 5. Licencja.;JavaScript;;true
What is webpack?;So, Angular CLI uses a webpack which is a build tool it gets all our scripts and stylesheets combines them outs them in a bundle and minifies that bundle and this is for optimization.;Więc Angular CLI używa webpacka, który jest narzędziem do kompilacji, pobiera wszystkie nasze skrypty i arkusze stylów, łączy je w pakiecie i minimalizuje ten pakiet, a to służy optymalizacji.;JavaScript;;true
What is git Squash?;Squash means to combine multiple commits into one. It is most often done when merging branches. Squashing is an option when performing for example rebase or merge, there is no separate command git squash.;Squash oznacza połączenie wielu commitów w jedno. Najczęściej odbywa się to podczas mergowania branchów. Squashing jest opcją podczas wykonywania przykładowo rebase'a lub merge'a, nie ma oddzielnego polecenia git squash.;OOP;;true
What's async vs defer difference in <script> tag?;1. Async in <script> tag in JavaScript is a way to load scripts asynchronously. That means, if a script is async, it will be loaded independently of other scripts on the page, and will not block the page from loading. 2. By using the defer attribute in HTML, the browser will load the script only after parsing (loading) the page. This can be helpful if you have a script that is dependent on other scripts, or if you want to improve the loading time of your page by loading scripts after the initial page load.;1. Async w tagu <script> w JavaScript'cie to sposób na asynchroniczne ładowanie skryptów. Oznacza to, że jeśli skrypt jest asynchroniczny, zostanie załadowany niezależnie od innych skryptów na stronie i nie zablokuje wczytywania strony. 2. Używając atrybutu defer, przeglądarka załaduje skrypt dopiero po załadowaniu strony.;JavaScript;;true
Wymień Utility Types w TypeScript'cie.;1. Partial<Type> a type with all properties of Type set to optional. This utility will return a type that represents all subsets of given type. 2. Required<Type> a type consisting of all properties of Type set to required. Przeciwieństwo Partial<Type>. 3. Readonly<Type> a type with all properties of Type set to readonly, meaning the properties of the constructed type cannot be reassigned. 4. Record<Keys, Type> an object type whose property keys are Keys and whose property values are Type. 5. Omit<Type, Keys> a type that contains of all properties from Type minus Keys. 6. NonNullable<Type> a type excluding null and undefined from Type.;1. Partial<Type> typ ze wszystkimi propertiesami Type ustawionymi na opcjonalne. Typ reprezentujący wszystkie podzbiory danego typu. 2. Required<Type> typ składający się ze wszystkich propertisów typu i są one wymagane. Przeciwieństwo Partial<Type>. 3. Readonly<Type> typ ze wszystkimi właściwościami Type ustawionymi na tylko do odczytu, co oznacza, że ​​propertisy nie mogą być ponownie przypisane. 4. Record<Keys, Type> typ obiektu, którego propertisami są Keys, a wartościami propertisów są Type. 5. Omit<Type, Keys>, który zawiera wszystkie propertisy z typu minus Keys. 6. NonNullable<Type> typ wykluczający null i undefined z Type.;TypeScript;;true
What is ECMAScript? (es6);ECMAScript is a JavaScript standard intended to ensure the interoperability of web pages across different browsers.;ECMAScript to standard JavaScript, którego celem jest zapewnienie interoperacyjności stron internetowych w różnych przeglądarkach.;JavaScript;;true
What is ESLint and file .eslintrc.json?;ESLint is a tool for detecting syntax errors, .eslintrc.json is it's configuration file, where the rules to be applied are placed, e.g. no-non-null-assertion, no-empty-function, no-explicit-any.;ESLint to narzędzie do wykrywania błędów składniowych, natomiast .eslintrc.json to jego plik konfiguracyjny, gdzie umieszczane są zasady jakich ma się stosować, np. no-non-null-assertion, no-empty-function, no-explicit-any.;TypeScript;;true
What is Angular Http Interceptor and what are it's use cases?;Angular Interceptor works on the request sent to the backend just before it is sent. We can say that it's a medium between backend and frontend applications. Each time a request is sent, the interceptors intercept it. They can also identify the response of a given request and also perform a number of operations on it. They are useful when, for example, we want to attach headers to each sent request, i.e. an authentication token, we can create global error handling in the interceptor, although I don't think it's a good idea, we can enable the loader on the page when the request is sent using the interceptor.;Angular Interceptor działa na requeście wysyłanym do backendu tóż przed jego wysłaniem. Można powiedzieć, że łączy aplikacje backendowe i frontendowe. Za każdym razem, gdy wysyłany jest request, interceptory go przechwytują. Mogą również zidentyfikować odpowiedź danego requestu i również wykonać na nim szereg operacji. Są użyteczne jak chcemy np. dołączać nagłówki do każdego wysyłanego requestu tj. token autentykujący, możemy stworzyć globalną obsługę błędów w interceptorze, choć ja nie uważam tego za dobry pomysł, możemy włączać loader na stronie jak request jest wysyłany za pomocą interceptora.;Angular;;true
What is DomSanitizer in Angular? (it inherits from abstract class Sanitizer);Sanitizer is used by the views to sanitize potentially dangerous values. DomSanitizer helps preventing Cross Site Scripting Security bugs (XSS) by sanitizing values to be safe to use in the different DOM contexts.;Sanitizer jest używany przez widoki do oczyszczania potencjalnie niebezpiecznych wartości. DomSanitizer pomaga zapobiegać błędom Cross Site Scripting Security (XSS) poprzez oczyszczanie wartości, aby były bezpieczne w użyciu w różnych kontekstach DOM.;Angular;;true
What are source map files for? (source maps, sourcemaps));Source maps are helpful for code debugging. I write my code in TypeScript and the compiler converts it to JavaScript. When the application runs in a browser, it uses JavaScript code. With source map files, even if the browser is running this JavaScript, if I open the debugger it will display the TypeScript source code and let me set breakpoints in it. The debugger is able to do this thanks to source map files, which map the TypeScript source code to the JavaScript code in which the application is running.;Source maps są pomocne przy debugowaniu kodu. Piszę swój kod w TypeScript'cie, a kompilator zamienia ten kod na JavaScript. Gdy aplikacja działa w przeglądarce używa ona kodu JavaScript. Z plikami source map nawet jeśli przeglądarka uruchamia ten JavaScript, jeśli otworzę debuger wyświetli on kod źródłowy TypeScript i pozwoli mi ustawić w nim breakpointy. Debuger jest w stanie to zrobić dzięki plikom source map, które odwzorowują kod źródłowy TypeScript na kod JavaScript, w którym jest aplikacja uruchomione.;JavaScript;;true
What is ExpressionChangedAfterItHasBeenCheckedError?;What is ExpressionChangedAfterItHasBeenCheckedError?;„ExpressionChangedAfterItHasBeenCheckedError” to błąd występujący w Angularze gdy wartości lub stan komponentu aktualizują się po zakończeniu przez Angular pierwszego sprawdzenia komponentu. Dzieje się tak często, gdy komponent aktualizuje swoją własną wartość np. w ngAfterViewInit. Aby rozwiązać ten problem, należy umieścić kod aktualizacji wartości w parametrze setTimeout z limitem czasu równym 0, co spowoduje aktualizację w następnej turze. Alternatywnie możesz ręcznie wykrywanie zmian, używając klasy ChangeDetectorRef i jej metody seekChanges.;Angular;;true
What is statically typed language?;Statically typed is a programming language characteristic in which variable types are explicitly declared and thus are determined at compile time. This lets the compiler decide whether a given variable can perform the actions requested from it or not.;Statycznie typowany język programowania charakteryzuje się typami zmiennych, które są jawnie zadeklarowane i określane podczas kompilacji. W ten sposób sposób na etapie kompilacji dowiadujemy się czy dana zmienna może wykonać czynności jej przypisane.;TypeScript;;true